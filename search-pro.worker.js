const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":76,\"nextId\":76,\"documentIds\":{\"0\":\"0\",\"1\":\"0#✨-初衷\",\"2\":\"0#🧱-笔记结构\",\"3\":\"0#🍥-搭建-learndata\",\"4\":\"0#🔣-配置-learndata\",\"5\":\"0#文档结构\",\"6\":\"0#看板娘\",\"7\":\"0#读书笔记\",\"8\":\"0#本地图片引用\",\"9\":\"0#🖥️-网站部署\",\"10\":\"0#同步到服务器\",\"11\":\"0#部署到-vercel\",\"12\":\"0#🤔-常见问题\",\"13\":\"0#网页显示异常\",\"14\":\"0#同步服务器报错\",\"15\":\"0#get-counter-failed-with-403\",\"16\":\"0#err-module\",\"17\":\"0#本地运行-learndata\",\"18\":\"2\",\"19\":\"2@0\",\"20\":\"2@1\",\"21\":\"3\",\"22\":\"3@0\",\"23\":\"3@1\",\"24\":\"4\",\"25\":\"4#三大特性\",\"26\":\"4#封装\",\"27\":\"4#继承\",\"28\":\"4#多态\",\"29\":\"4#类图\",\"30\":\"4#泛化关系-generalization\",\"31\":\"4#实现关系-realization\",\"32\":\"4#聚合关系-aggregation\",\"33\":\"4#组合关系-composition\",\"34\":\"4#关联关系-association\",\"35\":\"4#依赖关系-dependency\",\"36\":\"4#参考资料\",\"37\":\"5\",\"38\":\"5#相关文章\",\"39\":\"6\",\"40\":\"6#入门推荐\",\"41\":\"6#进阶推荐\",\"42\":\"6#参考文章\",\"43\":\"7\",\"44\":\"7#引入\",\"45\":\"7#代理的创建\",\"46\":\"7#获取所有的advisor\",\"47\":\"7#创建代理的入口方法\",\"48\":\"7#依据条件创建代理-jdk或cglib\",\"49\":\"8\",\"50\":\"8#引入\",\"51\":\"8#beanfactory中getbean的主体思路\",\"52\":\"8#初步的思考\",\"53\":\"8#spring中getbean的主体思路\",\"54\":\"8#重点-spring如何解决循环依赖问题\",\"55\":\"8#spring单例模式下的属性依赖\",\"56\":\"8#spring为何不能解决非单例属性之外的循环依赖\",\"57\":\"8#spring为什么不能解决构造器的循环依赖\",\"58\":\"8#spring为什么不能解决prototype作用域循环依赖\",\"59\":\"8#spring为什么不能解决多例的循环依赖\",\"60\":\"8#那么其它循环依赖如何解决\",\"61\":\"8#重点-spring中bean的生命周期\",\"62\":\"8#spring-bean生命周期流程\",\"63\":\"8#spring-bean生命周期案例\",\"64\":\"8#spring-bean生命周期源码\",\"65\":\"8#参考文章\",\"66\":\"9\",\"67\":\"10\",\"68\":\"11\",\"69\":\"12\",\"70\":\"13\",\"71\":\"14\",\"72\":\"15\",\"73\":\"16\",\"74\":\"17\",\"75\":\"18\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,3],\"1\":[2,32],\"2\":[2,29],\"3\":[3,116],\"4\":[3],\"5\":[1,102],\"6\":[1,48],\"7\":[1,47],\"8\":[1,23],\"9\":[2,32],\"10\":[1,28],\"11\":[2,59],\"12\":[2],\"13\":[1,42],\"14\":[1,53],\"15\":[5,26],\"16\":[2,27],\"17\":[2,35],\"18\":[1,7],\"19\":[null,null,1],\"20\":[null,null,2],\"21\":[1,7],\"22\":[null,null,1],\"23\":[null,null,2],\"24\":[3,25],\"25\":[1],\"26\":[1,79],\"27\":[1,28],\"28\":[1,51],\"29\":[1,8],\"30\":[3,15],\"31\":[3,16],\"32\":[3,13],\"33\":[3,15],\"34\":[3,22],\"35\":[3,28],\"36\":[1,44],\"37\":[2,6],\"38\":[1,119],\"39\":[2,275],\"40\":[1,21],\"41\":[1,6],\"42\":[1,19],\"43\":[4,19],\"44\":[1,42],\"45\":[1,94],\"46\":[1,115],\"47\":[1,151],\"48\":[3,64],\"49\":[6,36],\"50\":[1,18],\"51\":[1,17],\"52\":[1,28],\"53\":[1,191],\"54\":[2,5],\"55\":[1,155],\"56\":[2,3],\"57\":[2,10],\"58\":[2,6],\"59\":[2,4],\"60\":[2,22],\"61\":[2,38],\"62\":[2,131],\"63\":[2,151],\"64\":[2],\"65\":[1,12],\"66\":[1,3],\"67\":[1],\"68\":[2],\"69\":[1],\"70\":[1],\"71\":[1],\"72\":[1],\"73\":[1],\"74\":[1],\"75\":[1]},\"averageFieldLength\":[1.7248174263409721,47.266612288438196,0.25595238095238093],\"storedFields\":{\"0\":{\"h\":\"达伽马\",\"t\":[\"开源工具、效率方法、心理学探索的自我提升笔记\"]},\"1\":{\"h\":\"✨ 初衷\",\"t\":[\"曾经，我采用了 Notion、Obsidian 和 飞书 等多款知识管理工具来存储我的心得与笔记。然而，这种方式导致我的资料分散，难以管理和分享。\",\"更重要的是，笔记里的知识并不属于你，只有经过消化、应用，才会成为我们的财富。\",\"为此，我基于 VuePress 和 vuepress-theme-hope 构建了 LearnData 开源笔记，将我所有的笔记与文章聚合到同一页面形成知识库，便于集中管理和分享。\",\"笔记 + 文章 = LearnData 知识库\",\"笔记/博客自动化发布\"]},\"2\":{\"h\":\"🧱 笔记结构\",\"t\":[\"置顶：日常习惯、健身、阅读；\",\"软件应用：常用应用、Chrome 扩展和相关教程；\",\"Docker 服务：NAS 和服务器上的后端应用，以 Docker 容器为主；\",\"系统问题：Windows 系统优化和相关问题；\",\"代码编程：常用代码的学习和使用笔记，页面开发攻略和网站相关的工具和知识收集；\",\"生活角落：说明书、生活记录和小技巧；\",\"博客汇总：聚合所有博客文章，以分类、标签、时间轴等方式进行组合。\"]},\"3\":{\"h\":\"🍥 搭建 LearnData\",\"t\":[\"首先，访问 LearnData 项目页面，然后点击页面右上角的「Use this template」按钮。在弹出的页面中选择「Create a new repository」以创建一个基于此模板的新仓库。\",\"进入你的项目仓库，点击「Settings」>「Actions」>「General」，找到页面底部的 Workflow permissions 设置。选中 Read and write permissions 选项，并点击保存。这一步骤是确保 GitHub Page 在部署时能够正确访问和修改你的仓库内容，避免因权限不足导致部署失败（报错 failed with exit code 128）。\",\"然后，请进入菜单栏顶部的「Actions」页签，选择最新的 workflow。在页面右上方点击「Re-run jobs」>「Re-run all jobs」，这样做可以触发 GitHub 自动重新生成并部署网页。如果设置无误，GitHub 会自动创建一个名为 gh-page 的分支，并在其中部署你的页面。\",\"接下来，返回「Settings」页面，修改 Repository name 为 你的用户名.github.io。例如，如果你的仓库链接是 https://github.com/xxx/LearnData，那么 xxx 就是你的 GitHub 用户名。若该名称已被其他项目使用，系统会显示红色错误提示。此时，你可以选择任意其他名称，例如 LearnData，部署页面路径将变为 你的用户名.github.io/LearnData。如果页面样式显示不正常，可能需要设置子域名，具体方法可以参考页面底部的常见问题 - 网页显示异常。\",\"在「Settings」>「Pages」>「Build and deployment」>「Branch」中，将 gh-page 分支设置为 GitHub Pages 的源。大部分情况下，网站运行目录保持默认的 /(root) 即可。完成设置后，不要忘记点击「Save」保存。如果在此步骤中未找到 gh-pages 分支，请回到第三步重新触发一次 workflow，或尝试修改仓库中的任意文件以手动启动 GitHub Action。\",\"设置完成后，稍等几分钟再刷新页面，你将看到一个新的访问链接提示：https://你的用户名.github.io/。此时，你的个人知识库已经成功搭建，并且可以通过此链接访问了。\"]},\"4\":{\"h\":\"🔣 配置 LearnData\"},\"5\":{\"h\":\"文档结构\",\"t\":[\"LearnData 网站的配置和文本都存放在 docs 文件夹中。文章和页面的配置可参考主目录下的 samplepage.md。其中，order 参数表示侧边栏的顺序，数字越小越靠前，支持非整数和负数。我个人的偏好是将非干货或随想短文的 order 设置在 -0.01 到 -0.99，将干货类长文的 order 设置在 -1 到负无穷。每次新增文章都会在上一篇的基础上递减 order 值。这种设置使我能随时记录低于 1000 字的短文，同时不会影响那些寻求干货文章的用户体验，因为干货文章的排序始终保持在最上方。\",\"docs 目录结构如下：\",\"docs |── .vuepress # 网站配置 │ ├── config.ts # 网站环境依赖和网站属性 │ ├── sidebar.ts # 侧边栏 │ ├── navbar.ts # 导航栏 │ ├── theme.ts # 主题和插件 │ └── templateBuild.html # 网页模板，网站关键词和统计 |── _posts # 博客文章目录 ├── _temp # 草稿箱 ├── reading # 读书笔记 ├── anyname # 自定义笔记 ├── blog.md # 博客页面 └── intro.md # 博主个人介绍\",\"docs/.vuepress 路径下是网站的配置文件，我已添加了详细的注释。你可以参考注释和 vuepress-theme-hope 配置案例来调整配置。请在 docs/.vuepress/sidebar.ts 文件中修改文件夹路径，后台会自动抓取路径下的 md 文件来生成侧边栏。docs/.vuepress/theme.ts 有评论插件的相关配置。\",\"注意：\",\"LearnData 默认采用 algolia 进行全文检索。如果你没用 algolia，可在 docs/.vuepress/theme.ts 文件的 plugins 部分删除 docsearch 区块，并激活 searchPro。这样，网站将转用本地全文索引来进行搜索。\",\"docs/_temp 文件夹默认不同步到 GitHub 上。你可以手动在本地建立 _temp 文件夹，用来存放草稿。\",\"自 VuePress2 的 beta.54 版本开始，文件夹名前缀为 _ 在生成链接时将被省略，例如文章路径为 /_posts/，但网页链接路径会是 /posts/。\"]},\"6\":{\"h\":\"看板娘\",\"t\":[\"LearnData 集成了看板娘 Live2D Widget，支持随机对话、切换人物服饰和玩打飞机游戏，能提升网站美观度和趣味性。如果不需要看板娘，可以删除 docs\\\\.vuepress\\\\public 下的 live2d-widget 文件夹。\",\"如果网站部署在子页面 https://xxx.github.io/yyy，则需将子页面路径 yyy 加入到以下两个文件：\",\"将 docs\\\\.vuepress\\\\public\\\\live2d-widget\\\\autoload.js 文件第三行的 const live2d_path = \\\"/live2d-widget/\\\" 修改为 const live2d_path = \\\"/yyy/live2d-widget/\\\"。\",\"将 docs\\\\.vuepress\\\\templateBuild.html 文件中看板娘区块代码 <script src=\\\"/live2d-widget/autoload.js\\\"> 修改为 <script src=\\\"/yyy/live2d-widget/autoload.js\\\">。\",\"如果你想要修改看板娘模型，请参考 docs\\\\.vuepress\\\\public\\\\live2d-widget 路径下的 README 和修改说明。如果你想在服务器上自建 live2d api，请注意添加跨域配置，否则可能会出现只显示文字而不显示看板娘图片的情况。\"]},\"7\":{\"h\":\"读书笔记\",\"t\":[\"读书笔记中可能会有大量的原文引用，这与 LearnData 精简化知识点的初衷并不相符。因此，我们使用 docsify 来构建读书笔记，并将其放置于 docs/reading 目录下。在生成静态页面后，该路径下的文件不会被转换为 HTML 文件，而是将被自动复制到静态网站下，完成 docsify 页面构建和独立的读书笔记搜索索引。\",\"由于读书笔记架构更换到 docsify，不能使用相对链接。请调整 docs\\\\.vuepress\\\\sidebar.ts 的 { text: \\\"读书笔记\\\", icon: \\\"read\\\", link: \\\"https://newzone.top/reading/\\\" }，将 newzone.top 替换为你的博客域名。\",\"如果你没有部署 Waline，或不需统计阅读量和评论功能，可移除 docs\\\\reading\\\\index.html 中的 Waline 代码块。\",\"waline: { serverURL: \\\"https://waline.newzone.top\\\", ... }\"]},\"8\":{\"h\":\"本地图片引用\",\"t\":[\"为了避免在生成静态页面时出现 Rollup failed to resolve import 错误，本地图片必须保存在 docs/.vuepress/public 路径下。如果图片名称为 1.png，保存在 docs/.vuepress/public/imgs 路径下，则可以使用以下链接来引用该图片：/imgs/1.png 或使用 Markdown 图片链接：![](/imgs/1.png)。本方法也适用于将附件部署到网站上。\"]},\"9\":{\"h\":\"🖥️ 网站部署\",\"t\":[\"在将 LearnData 推送到 GitHub 后，会自动生成可访问的网页。但由于国内访问 GitHub Pages 的速度不稳定，为了确保网站能够正常访问，建议增加国内的访问节点。\",\"很多人选择使用 Gitee Pages 作为国内节点，通过 GitHub Actions 将新文档同步到 Gitee 上，从而生成位于国内的静态页面 Gitee Pages。但是，Gitee Pages 有很多限制，例如必须实名认证、免费版无法自定义域名，近期也发生过下架风波。因此，我没有选择 Gitee，而是将文档同步到国内服务器（域名需要备案）或 Vercel（国外服务可能会出现断网）。\"]},\"10\":{\"h\":\"同步到服务器\",\"t\":[\"如果你的项目已经搭建好，但出现了红色的叉叉提示，这可能是 GitHub Actions 同步到服务器时发生了错误。你需要进入项目仓库的「Setting」>「Secrets」>「Action」，并添加 FTP_HOST、FTP_PORT、FTP_USERNAME 和 FTP_PASSWORD 的密钥。之后，每当文件发生变化时，GitHub Actions 就会将修改推送到服务器的 FTP 上。\",\"你也可以参考文章 GitHub 同步到 OSS，将网页部署到云存储上。\"]},\"11\":{\"h\":\"部署到 Vercel\",\"t\":[\"Vercel 的速度相对 GitHub Pages 更快，但 *.vercel.app 域名已受 DNS 污染影响。为保证国内用户访问稳定，需绑定自定义域名。\",\"Vercel 部署步骤如下：\",\"点击 或将 https://vercel.com/new/clone?repository-url=https://github.com/rockbenben/LearnData/tree/gh-pages 中的 rockbenben/LearnData 改为 你的用户名/仓库名，然后会跳转至 Vercel 进行网页部署。如果你未登录，Vercel 提示你注册或登录，请使用 GitHub 账户进行快捷登录。\",\"输入一个你喜欢的 Vercel 项目名称，默认 private 即可，然后点击 Create。\",\"创建 Vercel 项目\",\"接着，Vercel 会基于 LearnData 模板帮助你新建并初始化仓库，仓库名为你之前输入的项目名。几十秒后，满屏的烟花会庆祝你部署成功。此时，点击 Go to Dashboard 跳转到应用的控制台。\",\"Vercel 部署成功提示\"]},\"12\":{\"h\":\"🤔 常见问题\"},\"13\":{\"h\":\"网页显示异常\",\"t\":[\"如果你的网站仅显示文本而不正常加载样式和脚本，可能是因为网站路径设置错误。这通常发生在将仓库作为子路径部署时，例如 https://xxx.github.io/LearnData/。\",\"解决步骤如下：\",\"找到配置文件：在你的项目中，打开 docs/.vuepress/config.ts。\",\"修改 base 设置：将 base 配置项的值更改为你的子路径 /LearnData/。\",\"export default defineUserConfig({ base: '/LearnData/', // 其他配置... });\",\"提交并推送更改。等待 GitHub Actions 自动重新部署网站。\",\"部署后，刷新网站应能正常显示。\",\"通过正确配置 base 路径，你的网站将能够加载所有必要的资源文件，从而正确显示样式和功能。如果你的网站是部署在根路径（如 https://xxx.github.io/），那么 base 应保留默认值 /。\"]},\"14\":{\"h\":\"同步服务器报错\",\"t\":[\"Error: Input required and not supplied: server 表示服务器配置错误，请按照上方的网站部署步骤检查配置。如果你不需要将网页部署同步到服务器，可以删除 .github/workflows/main.yml 中 Sync files 区块的代码。\",\"FTPError: 530 Login authentication failed 指 FTP 密码错误或账号不存在，可使用 FileZilla 来测试 FTP 的有效性。\",\"Error: Timeout (control socket) 指同步服务器出现超时报错。如果出现该错误，可以进入 Actions 页面，点击右侧按钮「Re-run all jobs」，重新进行部署。如果错误连续出现，可以尝试关闭服务器防火墙，检查 GitHub 服务器 IP 是否屏蔽了。\"]},\"15\":{\"h\":\"Get counter failed with 403\",\"t\":[\"Get counter failed with 403 错误仅在本地运行 pnpm docs:dev 时使用非 localhost 域名会发生，静态构建过程中不会出现。这是由评论插件 Waline 引起的。要解决这个问题，只需在 docs/.vuepress/theme.ts 文件中的 plugins 部分删除 Waline 配置。\"]},\"16\":{\"h\":\"ERR_MODULE\",\"t\":[\"如果出现 Error [ERR_MODULE_NOT_FOUND]: Cannot find module 的报错，可能是第三方插件或 pacakge.json 环境依赖未正确配置。此报错出现的几率极低，如果遇到，可以使用最新版本的 package.json 和 pnpm-lock.yaml 来覆盖本地设置，或者删除主目录下的 .npmrc 文件。\"]},\"17\":{\"h\":\"本地运行 LearnData\",\"t\":[\"为了本地运行，你需要安装 npm 和 pnpm 环境，可参考环境部署教程。\",\"将 LearnData 项目下载到本地后，在项目目录下打开终端，输入命令 pnpm i 安装依赖。\",\"在终端中输入命令 pnpm docs:dev，若成功则会提示访问链接，默认为 http://localhost:8080/。\",\"本地服务运行后，修改文件时页面会同步更新预览。若需停止本地服务器，可在终端中按下 Ctrl + C。\",\"如果你想深入了解 LearnData 的高级技巧，请浏览 LearnData 博客：高效知识管理和进阶应用技巧。\"]},\"18\":{\"h\":\"博客文章样例\",\"t\":[\"博客文章内容，支持 Markdown 和 HTML 语言。\"]},\"19\":{\"c\":[\"使用指南\"]},\"20\":{\"c\":[\"页面配置\",\"使用指南\"]},\"21\":{\"h\":\"博客文章样例2\",\"t\":[\"博客文章内容，支持 Markdown 和 HTML 语言。\"]},\"22\":{\"c\":[\"工具\"]},\"23\":{\"c\":[\"页面配置\",\"使用指南\"]},\"24\":{\"h\":\"Java 基础 - 面向对象\",\"t\":[\"本文主要介绍Java OOP 面向对象基础和相关类图。@pdai\",\"Java 基础 - 面向对象\",\"三大特性\",\"封装\",\"继承\",\"多态\",\"类图\",\"泛化关系 (Generalization)\",\"实现关系 (Realization)\",\"聚合关系 (Aggregation)\",\"组合关系 (Composition)\",\"关联关系 (Association)\",\"依赖关系 (Dependency)\",\"参考资料\"]},\"25\":{\"h\":\"三大特性\"},\"26\":{\"h\":\"封装\",\"t\":[\"利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。\",\"优点:\",\"减少耦合: 可以独立地开发、测试、优化、使用、理解和修改\",\"减轻维护的负担: 可以更容易被程序员理解，并且在调试的时候可以不影响其他模块\",\"有效地调节性能: 可以通过剖析确定哪些模块影响了系统的性能\",\"提高软件的可重用性\",\"降低了构建大型系统的风险: 即使整个系统不可用，但是这些独立的模块却有可能是可用的\",\"以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。\",\"注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。\",\"public class Person { private String name; private int gender; private int age; public String getName() { return name; } public String getGender() { return gender == 0 ? \\\"man\\\" : \\\"woman\\\"; } public void work() { if (18 <= age && age <= 50) { System.out.println(name + \\\" is working very hard!\\\"); } else { System.out.println(name + \\\" can't work any more!\\\"); } } }\"]},\"27\":{\"h\":\"继承\",\"t\":[\"继承实现了 IS-A 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。\",\"继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。\",\"Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 向上转型 。\",\"Animal animal = new Cat();\"]},\"28\":{\"h\":\"多态\",\"t\":[\"多态分为编译时多态和运行时多态:\",\"编译时多态主要指方法的重载\",\"运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定\",\"运行时多态有三个条件:\",\"继承\",\"覆盖(重写)\",\"向上转型\",\"下面的代码中，乐器类(Instrument)有两个子类: Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。\",\"public class Instrument { public void play() { System.out.println(\\\"Instrument is playing...\\\"); } } public class Wind extends Instrument { public void play() { System.out.println(\\\"Wind is playing...\\\"); } } public class Percussion extends Instrument { public void play() { System.out.println(\\\"Percussion is playing...\\\"); } } public class Music { public static void main(String[] args) { List<Instrument> instruments = new ArrayList<>(); instruments.add(new Wind()); instruments.add(new Percussion()); for(Instrument instrument : instruments) { instrument.play(); } } }\"]},\"29\":{\"h\":\"类图\",\"t\":[\"以下类图使用 PlantUML在新窗口打开 绘制，更多语法及使用请参考: http://plantuml.com/ 。\"]},\"30\":{\"h\":\"泛化关系 (Generalization)\",\"t\":[\"用来描述继承关系，在 Java 中使用 extends 关键字。\",\"@startuml title Generalization class Vehical class Car class Truck Vehical <|-- Car Vehical <|-- Truck @enduml\"]},\"31\":{\"h\":\"实现关系 (Realization)\",\"t\":[\"用来实现一个接口，在 Java 中使用 implements 关键字。\",\"@startuml title Realization interface MoveBehavior class Fly class Run MoveBehavior <|.. Fly MoveBehavior <|.. Run @enduml\"]},\"32\":{\"h\":\"聚合关系 (Aggregation)\",\"t\":[\"表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。\",\"@startuml title Aggregation class Computer class Keyboard class Mouse class Screen Computer o-- Keyboard Computer o-- Mouse Computer o-- Screen @enduml\"]},\"33\":{\"h\":\"组合关系 (Composition)\",\"t\":[\"和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。\",\"@startuml title Composition class Company class DepartmentA class DepartmentB Company *-- DepartmentA Company *-- DepartmentB @enduml\"]},\"34\":{\"h\":\"关联关系 (Association)\",\"t\":[\"表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。\",\"@startuml title Association class School class Student School \\\"1\\\" - \\\"n\\\" Student @enduml\"]},\"35\":{\"h\":\"依赖关系 (Dependency)\",\"t\":[\"和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式:\",\"A 类是 B 类中的(某中方法的)局部变量；\",\"A 类是 B 类方法当中的一个参数；\",\"A 类向 B 类发送消息，从而影响 B 类发生变化；\",\"@startuml title Dependency class Vehicle { move(MoveBehavior) } interface MoveBehavior { move() } note \\\"MoveBehavior.move()\\\" as N Vehicle ..> MoveBehavior Vehicle .. N @enduml\"]},\"36\":{\"h\":\"参考资料\",\"t\":[\"Java 编程思想\",\"敏捷软件开发: 原则、模式与实践\",\"面向对象设计的 SOLID 原则在新窗口打开\",\"看懂 UML 类图和时序图在新窗口打开\",\"UML 系列——时序图(顺序图)sequence diagram在新窗口打开\",\"面向对象编程三大特性 ------ 封装、继承、多态在新窗口打开\",\"javaoop基础知识总结 https://blog.csdn.net/weixin_38173324/article/details/70037927\",\"Java实现OOP(面向对象编程) https://www.cnblogs.com/AlanLee/p/6475334.html\",\"Java 抽象类与oop三大特征 http://www.cnblogs.com/wujing-hubei/p/6012105.html\"]},\"37\":{\"h\":\"# ♥Spring框架知识体系详解♥\",\"t\":[\"提示\",\"本系列主要介绍Spring框架整体架构，Spring的核心IOC，AOP的案例和具体实现机制；以及SpringMVC框架的案例和实现机制。@pdai\"]},\"38\":{\"h\":\"相关文章\",\"t\":[\"首先， 从Spring框架的整体架构和组成对整体框架有个认知。\",\"Spring基础 - Spring和Spring框架组成\",\"Spring是什么？它是怎么诞生的？有哪些主要的组件和核心功能呢? 本文通过这几个问题帮助你构筑Spring和Spring Framework的整体认知。\",\"其次，通过案例引出Spring的核心（IoC和AOP），同时对IoC和AOP进行案例使用分析。\",\"Spring基础 - Spring简单例子引入Spring的核心\",\"上文中我们简单介绍了Spring和Spring Framework的组件，那么这些Spring Framework组件是如何配合工作的呢？本文主要承接上文，向你展示Spring Framework组件的典型应用场景和基于这个场景设计出的简单案例，并以此引出Spring的核心要点，比如IOC和AOP等；在此基础上还引入了不同的配置方式， 如XML，Java配置和注解方式的差异。\",\"Spring基础 - Spring核心之控制反转(IOC)\",\"在Spring基础 - Spring简单例子引入Spring的核心中向你展示了IoC的基础含义，同时以此发散了一些IoC相关知识点; 本节将在此基础上进一步解读IOC的含义以及IOC的使用方式\",\"Spring基础 - Spring核心之面向切面编程(AOP)\",\"在Spring基础 - Spring简单例子引入Spring的核心中向你展示了AOP的基础含义，同时以此发散了一些AOP相关知识点; 本节将在此基础上进一步解读AOP的含义以及AOP的使用方式。\",\"基于Spring框架和IOC，AOP的基础，为构建上层web应用，需要进一步学习SpringMVC。\",\"Spring基础 - SpringMVC请求流程和案例\",\"前文我们介绍了Spring框架和Spring框架中最为重要的两个技术点（IOC和AOP），那我们如何更好的构建上层的应用呢（比如web 应用），这便是SpringMVC；Spring MVC是Spring在Spring Container Core和AOP等技术基础上，遵循上述Web MVC的规范推出的web开发框架，目的是为了简化Java栈的web开发。 本文主要介绍SpringMVC的请求流程和基础案例的编写和运行。\",\"Spring进阶 - IoC，AOP以及SpringMVC的源码分析\",\"Spring进阶 - Spring IOC实现原理详解之IOC体系结构设计\",\"在对IoC有了初步的认知后，我们开始对IOC的实现原理进行深入理解。本文将帮助你站在设计者的角度去看IOC最顶层的结构设计\",\"Spring进阶 - Spring IOC实现原理详解之IOC初始化流程\",\"上文，我们看了IOC设计要点和设计结构；紧接着这篇，我们可以看下源码的实现了：Spring如何实现将资源配置（以xml配置为例）通过加载，解析，生成BeanDefination并注册到IoC容器中的\",\"Spring进阶 - Spring IOC实现原理详解之Bean实例化(生命周期,循环依赖等)\",\"上文，我们看了IOC设计要点和设计结构；以及Spring如何实现将资源配置（以xml配置为例）通过加载，解析，生成BeanDefination并注册到IoC容器中的；容器中存放的是Bean的定义即BeanDefinition放到beanDefinitionMap中，本质上是一个ConcurrentHashMap<String, Object>；并且BeanDefinition接口中包含了这个类的Class信息以及是否是单例等。那么如何从BeanDefinition中实例化Bean对象呢，这是本文主要研究的内容？\",\"Spring进阶 - Spring AOP实现原理详解之切面实现\",\"前文，我们分析了Spring IOC的初始化过程和Bean的生命周期等，而Spring AOP也是基于IOC的Bean加载来实现的。本文主要介绍Spring AOP原理解析的切面实现过程(将切面类的所有切面方法根据使用的注解生成对应Advice，并将Advice连同切入点匹配器和切面类等信息一并封装到Advisor，为后续交给代理增强实现做准备的过程)。\",\"Spring进阶 - Spring AOP实现原理详解之AOP代理\",\"上文我们介绍了Spring AOP原理解析的切面实现过程(将切面类的所有切面方法根据使用的注解生成对应Advice，并将Advice连同切入点匹配器和切面类等信息一并封装到Advisor)。本文在此基础上继续介绍，代理（cglib代理和JDK代理）的实现过程。\",\"Spring进阶 - Spring AOP实现原理详解之Cglib代理实现\",\"我们在前文中已经介绍了SpringAOP的切面实现和创建动态代理的过程，那么动态代理是如何工作的呢？本文主要介绍Cglib动态代理的案例和SpringAOP实现的原理。\",\"Spring进阶 - Spring AOP实现原理详解之JDK代理实现\",\"上文我们学习了SpringAOP Cglib动态代理的实现，本文主要是SpringAOP JDK动态代理的案例和实现部分。\",\"Spring进阶 - SpringMVC实现原理之DispatcherServlet初始化的过程\",\"前文我们有了IOC的源码基础以及SpringMVC的基础，我们便可以进一步深入理解SpringMVC主要实现原理，包含DispatcherServlet的初始化过程和DispatcherServlet处理请求的过程的源码解析。本文是第一篇：DispatcherServlet的初始化过程的源码解析。\",\"Spring进阶 - SpringMVC实现原理之DispatcherServlet处理请求的过程\",\"前文我们有了IOC的源码基础以及SpringMVC的基础，我们便可以进一步深入理解SpringMVC主要实现原理，包含DispatcherServlet的初始化过程和DispatcherServlet处理请求的过程的源码解析。本文是第二篇：DispatcherServlet处理请求的过程的源码解析。\"]},\"39\":{\"h\":\"# ♥数据结构基础知识体系详解♥\",\"t\":[\"提示\",\"对于数据结构这种基础内容，在构建其知识体系时要避免自己再造轮子，需要高一点层次整体上去理解它(格局要大一点，不要盯着代码)，要了解算法思想，性能及适用场景，用一些工具和别人梳理的结果帮助自己构建知识体系等。@pdai\",\"知识体系\",\"入门推荐\",\"进阶推荐\",\"参考文章# 知识体系\",\"知识体系系统性梳理\",\"学习思路\",\"避免孤立的学习知识点，要关联学习。比如实际应用当中，我们经常使用的是查找和排序操作，这在我们的各种管理系统、数据库系统、操作系统等当中，十分常用，我们通过这个线索将知识点串联起来：\",\"数组的下标寻址十分迅速，但计算机的内存是有限的，故数组的长度也是有限的，实际应用当中的数据往往十分庞大；而且无序数组的查找最坏情况需要遍历整个数组；后来人们提出了二分查找，二分查找要求数组的构造一定有序，二分法查找解决了普通数组查找复杂度过高的问题。任何一种数组无法解决的问题就是插入、删除操作比较复杂，因此，在一个增删查改比较频繁的数据结构中，数组不会被优先考虑\",\"普通链表由于它的结构特点被证明根本不适合进行查找\",\"哈希表是数组和链表的折中，同时它的设计依赖散列函数的设计，数组不能无限长、链表也不适合查找，所以也不适合大规模的查找\",\"二叉查找树因为可能退化成链表，同样不适合进行查找\",\"AVL树是为了解决可能退化成链表问题，但是AVL树的旋转过程非常麻烦，因此插入和删除很慢，也就是构建AVL树比较麻烦\",\"红黑树是平衡二叉树和AVL树的折中，因此是比较合适的。集合类中的Map、关联数组具有较高的查询效率，它们的底层实现就是红黑树。\",\"多路查找树 是大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的(如果元素数量非常多的话，查找就退化成节点内部的线性查找了)，这样导致二叉查找树结构由于树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下。\",\"B树与自平衡二叉查找树不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。它的应用是文件系统及部分非关系型数据库索引。\",\"B+树在B树基础上，为叶子结点增加链表指针(B树+叶子有序链表)，所有关键字都在叶子结点 中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中。通常用于关系型数据库(如Mysql)和操作系统的文件系统中。\",\"B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针, 在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3。\",\"R树是用来做空间数据存储的树状数据结构。例如给地理位置，矩形和多边形这类多维数据建立索引。\",\"Trie树是自然语言处理中最常用的数据结构，很多字符串处理任务都会用到。Trie树本身是一种有限状态自动机，还有很多变体。什么模式匹配、正则表达式，都与这有关。\",\"相关文章\",\"A. 数据结构 知识点：数据结构是基础中的基础，任何进阶都逃不开这些知识点。\",\"数据结构 - Overview\",\"B. 数据结构之 线性结构：首先理解数据结构中线性结构及其延伸：数组和矩阵，链表，栈和队列等。\",\"线性表 - 数组和矩阵\",\"数组是一种连续存储线性结构，元素类型相同，大小相等，数组是多维的，通过使用整型索引值来访问他们的元素，数组尺寸不能改变\",\"线性表 - 链表\",\"n个节点离散分配，彼此通过指针相连，每个节点只有一个前驱节点，每个节点只有一个后续节点，首节点没有前驱节点，尾节点没有后续节点。确定一个链表我们只需要头指针，通过头指针就可以把整个链表都能推出来\",\"线性表(散列) - 哈希表\",\"散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。@pdai\",\"线性表 - 栈和队列\",\"数组和链表都是线性存储结构的基础，栈和队列都是线性存储结构的应用\",\"C. 数据结构之 逻辑结构：树：然后理解数据结构中逻辑结构之树：二叉搜索树(BST)，平衡二叉树(AVL)，红黑树(R-B Tree)，哈夫曼树，前缀树(Trie)等。\",\"树 - 基础和Overview\",\"树在数据结构中至关重要，这里展示树的整体知识体系结构和几种常见树类型\",\"树 - 二叉搜索树(BST)\",\"本文主要介绍 二叉树中最基本的二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。\",\"树 - 平衡二叉树(AVL)\",\"平衡二叉树（Balanced Binary Tree）具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。 最小二叉平衡树的节点的公式如下 F(n)=F(n-1)+F(n-2)+1 这个类似于一个递归的数列，可以参考Fibonacci数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。\",\"树 - 红黑树(R-B Tree)\",\"红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组，是平衡二叉树和AVL树的折中。\",\"树 - 哈夫曼树\",\"哈夫曼又称最优二叉树, 是一种带权路径长度最短的二叉树。\",\"树 - 前缀树(Trie)\",\"Trie，又称字典树、单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。\",\"D. 数据结构之 逻辑结构：图：最后理解数据结构中逻辑结构之图：图基础，图的遍历，最小生成树(Prim & Kruskal)，最短路径(Dijkstra & Frolyd)，拓扑排序(Topological sort)，AOE & 关键路径等。\",\"图 - 基础和Overview\",\"图(Graph)是由顶点和连接顶点的边构成的离散结构。在计算机科学中，图是最灵活的数据结构之一，很多问题都可以使用图模型进行建模求解。例如: 生态环境中不同物种的相互竞争、人与人之间的社交与关系网络、化学上用图区分结构不同但分子式相同的同分异构体、分析计算机网络的拓扑结构确定两台计算机是否可以通信、找到两个城市之间的最短路径等等。\",\"图 - 遍历(BFS & DFS)\",\"图的深度优先搜索(Depth First Search)，和树的先序遍历比较类似; 广度优先搜索算法(Breadth First Search)，又称为\\\"宽度优先搜索\\\"或\\\"横向优先搜索\\\"\",\"图 - 最小生成树(Prim & Kruskal)\",\"Kruskal算法是从最小权重边着手，将森林里的树逐渐合并；prim算法是从顶点出发，在根结点的基础上建起一棵树\",\"图 - 最短路径(Dijkstra & Frolyd)\",\"最短路径有着广泛的应用，比如地图两点间距离计算，公交查询系统，路由选择等\",\"图 - 拓扑排序(Topological sort)\",\"拓扑排序主要用来解决有向图中的依赖解析(dependency resolution)问题\",\"图 - AOE & 关键路径\",\"关键路径在项目管理计算工期等方面有广泛等应用，提升工期就是所见缩减所有关键路径上的工期，并且在实现时需要应用到之前拓扑排序的算法(前提: 有向无环图，有依赖关系)\"]},\"40\":{\"h\":\"入门推荐\",\"t\":[\"强烈推荐用动画学习算法 Data Structure Visualizations在新窗口打开\",\"推荐一个学习数据结构的英文网站 Java Point - DS在新窗口打开\",\"推荐Github上java算法集合 TheAlgorithms - Java在新窗口打开\",\"推荐@skywang12345写的数据结构 skywang12345 - DS在新窗口打开\",\"推荐@QG-whz数据结构图画的好(本章节中有部分图源于这位作者) QG-whz在新窗口打开\",\"推荐@亦海数据结构的文章，写的很清晰 亦海 - DS在新窗口打开\"]},\"41\":{\"h\":\"进阶推荐\",\"t\":[\"首推@July结构之法 算法之道 July - 结构之法 算法之道在新窗口打开\"]},\"42\":{\"h\":\"参考文章\",\"t\":[\"https://www.cnblogs.com/small-boy/p/8039007.html\",\"https://www.jianshu.com/p/5c84f7b6c354\",\"https://blog.csdn.net/flowing_wind/article/details/81431354\"]},\"43\":{\"h\":\"# Spring进阶 - Spring AOP实现原理详解之AOP代理的创建\",\"t\":[\"上文我们介绍了Spring AOP原理解析的切面实现过程(将切面类的所有切面方法根据使用的注解生成对应Advice，并将Advice连同切入点匹配器和切面类等信息一并封装到Advisor)。本文在此基础上继续介绍，代理（cglib代理和JDK代理）的创建过程。@pdai\",\"Spring进阶 - Spring AOP实现原理详解之AOP代理的创建\",\"引入\",\"代理的创建\",\"获取所有的Advisor\",\"创建代理的入口方法\",\"依据条件创建代理(jdk或cglib)\"]},\"44\":{\"h\":\"引入\",\"t\":[\"前文主要Spring AOP原理解析的切面实现过程(加载配置，将切面类的所有切面方法根据使用的注解生成对应Advice，并将Advice连同切入点匹配器和切面类等信息一并封装到Advisor)。\",\"同时我们也总结了Spring AOP初始化的过程，具体如下：\",\"由IOC Bean加载方法栈中找到parseCustomElement方法，找到parse aop:aspectj-autoproxy的handler(org.springframework.aop.config.AopNamespaceHandler)\",\"AopNamespaceHandler注册了<aop:aspectj-autoproxy/>的解析类是AspectJAutoProxyBeanDefinitionParser\",\"AspectJAutoProxyBeanDefinitionParser的parse 方法 通过AspectJAwareAdvisorAutoProxyCreator类去创建\",\"AspectJAwareAdvisorAutoProxyCreator实现了两类接口，BeanFactoryAware和BeanPostProcessor；根据Bean生命周期方法找到两个核心方法：postProcessBeforeInstantiation和postProcessAfterInitialization \",\"postProcessBeforeInstantiation：主要是处理使用了@Aspect注解的切面类，然后将切面类的所有切面方法根据使用的注解生成对应Advice，并将Advice连同切入点匹配器和切面类等信息一并封装到Advisor\",\"postProcessAfterInitialization：主要负责将Advisor注入到合适的位置，创建代理（cglib或jdk)，为后面给代理进行增强实现做准备。\",\"本文接着介绍postProcessAfterInitialization的方法，即Spring AOP的代理（cglib或jdk)的创建过程。\"]},\"45\":{\"h\":\"代理的创建\",\"t\":[\"创建代理的方法是postProcessAfterInitialization：如果bean被子类标识为代理，则使用配置的拦截器创建一个代理\",\"/** * Create a proxy with the configured interceptors if the bean is * identified as one to proxy by the subclass. * @see #getAdvicesAndAdvisorsForBean */ @Override public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) { if (bean != null) { Object cacheKey = getCacheKey(bean.getClass(), beanName); // 如果不是提前暴露的代理 if (this.earlyProxyReferences.remove(cacheKey) != bean) { return wrapIfNecessary(bean, beanName, cacheKey); } } return bean; }\",\"wrapIfNecessary方法主要用于判断是否需要创建代理，如果Bean能够获取到advisor才需要创建代理\",\"/** * Wrap the given bean if necessary, i.e. if it is eligible for being proxied. * @param bean the raw bean instance * @param beanName the name of the bean * @param cacheKey the cache key for metadata access * @return a proxy wrapping the bean, or the raw bean instance as-is */ protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) { // 如果bean是通过TargetSource接口获取 if (beanName != null && this.targetSourcedBeans.contains(beanName)) { return bean; } // 如果bean是切面类 if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) { return bean; } // 如果是aop基础类？是否跳过？ if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) { this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean; } // 重点：获取所有advisor，如果没有获取到，那说明不要进行增强，也就不需要代理了。 Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null); if (specificInterceptors != DO_NOT_PROXY) { this.advisedBeans.put(cacheKey, Boolean.TRUE); // 重点：创建代理 Object proxy = createProxy( bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean)); this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; } this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean; }\"]},\"46\":{\"h\":\"获取所有的Advisor\",\"t\":[\"我们看下获取所有advisor的方法getAdvicesAndAdvisorsForBean\",\"@Override @Nullable protected Object[] getAdvicesAndAdvisorsForBean( Class<?> beanClass, String beanName, @Nullable TargetSource targetSource) { List<Advisor> advisors = findEligibleAdvisors(beanClass, beanName); if (advisors.isEmpty()) { return DO_NOT_PROXY; } return advisors.toArray(); }\",\"通过findEligibleAdvisors方法获取advisor， 如果获取不到返回DO_NOT_PROXY（不需要创建代理），findEligibleAdvisors方法如下\",\"/** * Find all eligible Advisors for auto-proxying this class. * @param beanClass the clazz to find advisors for * @param beanName the name of the currently proxied bean * @return the empty List, not {@code null}, * if there are no pointcuts or interceptors * @see #findCandidateAdvisors * @see #sortAdvisors * @see #extendAdvisors */ protected List<Advisor> findEligibleAdvisors(Class<?> beanClass, String beanName) { // 和上文一样，获取所有切面类的切面方法生成Advisor List<Advisor> candidateAdvisors = findCandidateAdvisors(); // 找到这些Advisor中能够应用于beanClass的Advisor List<Advisor> eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName); // 如果需要，交给子类拓展 extendAdvisors(eligibleAdvisors); // 对Advisor排序 if (!eligibleAdvisors.isEmpty()) { eligibleAdvisors = sortAdvisors(eligibleAdvisors); } return eligibleAdvisors; }\",\"获取所有切面类的切面方法生成Advisor\",\"/** * Find all candidate Advisors to use in auto-proxying. * @return the List of candidate Advisors */ protected List<Advisor> findCandidateAdvisors() { Assert.state(this.advisorRetrievalHelper != null, \\\"No BeanFactoryAdvisorRetrievalHelper available\\\"); return this.advisorRetrievalHelper.findAdvisorBeans(); }\",\"找到这些Advisor中能够应用于beanClass的Advisor\",\"/** * Determine the sublist of the {@code candidateAdvisors} list * that is applicable to the given class. * @param candidateAdvisors the Advisors to evaluate * @param clazz the target class * @return sublist of Advisors that can apply to an object of the given class * (may be the incoming List as-is) */ public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) { if (candidateAdvisors.isEmpty()) { return candidateAdvisors; } List<Advisor> eligibleAdvisors = new ArrayList<>(); for (Advisor candidate : candidateAdvisors) { // 通过Introduction实现的advice if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) { eligibleAdvisors.add(candidate); } } boolean hasIntroductions = !eligibleAdvisors.isEmpty(); for (Advisor candidate : candidateAdvisors) { if (candidate instanceof IntroductionAdvisor) { // already processed continue; } // 是否能够应用于clazz的Advice if (canApply(candidate, clazz, hasIntroductions)) { eligibleAdvisors.add(candidate); } } return eligibleAdvisors; }\"]},\"47\":{\"h\":\"创建代理的入口方法\",\"t\":[\"获取所有advisor后，如果有advisor，则说明需要增强，即需要创建代理，创建代理的方法如下：\",\"/** * Create an AOP proxy for the given bean. * @param beanClass the class of the bean * @param beanName the name of the bean * @param specificInterceptors the set of interceptors that is * specific to this bean (may be empty, but not null) * @param targetSource the TargetSource for the proxy, * already pre-configured to access the bean * @return the AOP proxy for the bean * @see #buildAdvisors */ protected Object createProxy(Class<?> beanClass, @Nullable String beanName, @Nullable Object[] specificInterceptors, TargetSource targetSource) { if (this.beanFactory instanceof ConfigurableListableBeanFactory) { AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass); } ProxyFactory proxyFactory = new ProxyFactory(); proxyFactory.copyFrom(this); if (proxyFactory.isProxyTargetClass()) { // Explicit handling of JDK proxy targets (for introduction advice scenarios) if (Proxy.isProxyClass(beanClass)) { // Must allow for introductions; can't just set interfaces to the proxy's interfaces only. for (Class<?> ifc : beanClass.getInterfaces()) { proxyFactory.addInterface(ifc); } } } else { // No proxyTargetClass flag enforced, let's apply our default checks... if (shouldProxyTargetClass(beanClass, beanName)) { proxyFactory.setProxyTargetClass(true); } else { evaluateProxyInterfaces(beanClass, proxyFactory); } } Advisor[] advisors = buildAdvisors(beanName, specificInterceptors); proxyFactory.addAdvisors(advisors); proxyFactory.setTargetSource(targetSource); customizeProxyFactory(proxyFactory); proxyFactory.setFrozen(this.freezeProxy); if (advisorsPreFiltered()) { proxyFactory.setPreFiltered(true); } // Use original ClassLoader if bean class not locally loaded in overriding class loader ClassLoader classLoader = getProxyClassLoader(); if (classLoader instanceof SmartClassLoader && classLoader != beanClass.getClassLoader()) { classLoader = ((SmartClassLoader) classLoader).getOriginalClassLoader(); } return proxyFactory.getProxy(classLoader); }\",\"proxyFactory.getProxy(classLoader)\",\"/** * Create a new proxy according to the settings in this factory. * <p>Can be called repeatedly. Effect will vary if we've added * or removed interfaces. Can add and remove interceptors. * <p>Uses the given class loader (if necessary for proxy creation). * @param classLoader the class loader to create the proxy with * (or {@code null} for the low-level proxy facility's default) * @return the proxy object */ public Object getProxy(@Nullable ClassLoader classLoader) { return createAopProxy().getProxy(classLoader); }\"]},\"48\":{\"h\":\"依据条件创建代理(jdk或cglib)\",\"t\":[\"DefaultAopProxyFactory.createAopProxy\",\"@Override public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException { if (!NativeDetector.inNativeImage() && (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config))) { Class<?> targetClass = config.getTargetClass(); if (targetClass == null) { throw new AopConfigException(\\\"TargetSource cannot determine target class: \\\" + \\\"Either an interface or a target is required for proxy creation.\\\"); } if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) { return new JdkDynamicAopProxy(config); } return new ObjenesisCglibAopProxy(config); } else { return new JdkDynamicAopProxy(config); } }\",\"几个要点\",\"config.isOptimize() 是通过optimize设置，表示配置是自定义的，默认是false；\",\"config.isProxyTargetClass()是通过<aop:config proxy-target-class=\\\"true\\\" /> 来配置的，表示优先使用cglib代理，默认是false；\",\"hasNoUserSuppliedProxyInterfaces(config) 表示是否目标类实现了接口\",\"由此我们可以知道：\",\"Spring默认在目标类实现接口时是通过JDK代理实现的，只有非接口的是通过Cglib代理实现的。当设置proxy-target-class为true时在目标类不是接口或者代理类时优先使用cglib代理实现。\"]},\"49\":{\"h\":\"# Spring进阶- Spring IOC实现原理详解之Bean实例化(生命周期,循环依赖等)\",\"t\":[\"上文，我们看了IOC设计要点和设计结构；以及Spring如何实现将资源配置（以xml配置为例）通过加载，解析，生成BeanDefination并注册到IoC容器中的；容器中存放的是Bean的定义即BeanDefinition放到beanDefinitionMap中，本质上是一个ConcurrentHashMap<String, Object>；并且BeanDefinition接口中包含了这个类的Class信息以及是否是单例等。那么如何从BeanDefinition中实例化Bean对象呢，这是本文主要研究的内容？@pdai\",\"Spring进阶- Spring IOC实现原理详解之Bean实例化(生命周期,循环依赖等)\",\"引入\",\"BeanFactory中getBean的主体思路\",\"初步的思考\",\"Spring中getBean的主体思路\",\"重点：Spring如何解决循环依赖问题\",\"Spring单例模式下的属性依赖\",\"Spring为何不能解决非单例属性之外的循环依赖？\",\"Spring为什么不能解决构造器的循环依赖？\",\"Spring为什么不能解决prototype作用域循环依赖？\",\"Spring为什么不能解决多例的循环依赖？\",\"那么其它循环依赖如何解决？\",\"重点：Spring中Bean的生命周期\",\"Spring Bean生命周期流程\",\"Spring Bean生命周期案例\",\"Spring Bean生命周期源码\",\"参考文章\"]},\"50\":{\"h\":\"引入\",\"t\":[\"上文，我们看了IOC设计要点和设计结构；\\b以及Spring如何实现将资源配置（以xml配置为例）通过加载，解析，生成BeanDefination并注册到IoC容器中的；容器中存放的是Bean的定义即BeanDefinition放到beanDefinitionMap中，本质上是一个ConcurrentHashMap<String, Object>；并且BeanDefinition接口中包含了这个类的Class信息以及是否是单例等。那么如何从BeanDefinition中实例化Bean对象呢？\",\"本文主要研究如何从IOC容器已有的BeanDefinition信息，实例化出Bean对象；这里还会包括三块重点内容：\",\"BeanFactory中getBean的主体思路\",\"Spring如何解决循环依赖问题\",\"Spring中Bean的生命周期\"]},\"51\":{\"h\":\"BeanFactory中getBean的主体思路\",\"t\":[\"上文中我们知道BeanFactory定义了Bean容器的规范，其中包含根据bean的名字, Class类型和参数等来得到bean实例。\",\"// 根据bean的名字和Class类型等来得到bean实例 Object getBean(String name) throws BeansException; Object getBean(String name, Class requiredType) throws BeansException; Object getBean(String name, Object... args) throws BeansException; <T> T getBean(Class<T> requiredType) throws BeansException; <T> T getBean(Class<T> requiredType, Object... args) throws BeansException;\"]},\"52\":{\"h\":\"初步的思考\",\"t\":[\"上文我们已经分析了IoC初始化的流程，最终的将Bean的定义即BeanDefinition放到beanDefinitionMap中，本质上是一个ConcurrentHashMap<String, Object>；并且BeanDefinition接口中包含了这个类的Class信息以及是否是单例等；\",\"这样我们初步有了实现Object getBean(String name)这个方法的思路：\",\"从beanDefinitionMap通过beanName获得BeanDefinition\",\"从BeanDefinition中获得beanClassName\",\"通过反射初始化beanClassName的实例instance \",\"构造函数从BeanDefinition的getConstructorArgumentValues()方法获取\",\"属性值从BeanDefinition的getPropertyValues()方法获取\",\"返回beanName的实例instance\",\"由于BeanDefinition还有单例的信息，如果是无参构造函数的实例还可以放在一个缓存中，这样下次获取这个单例的实例时只需要从缓存中获取，如果获取不到再通过上述步骤获取。\",\"（PS：如上只是我们初步的思路，而Spring还需要考虑各种设计上的问题，比如beanDefinition中其它定义，循环依赖等；所以我们来看下Spring是如何是如何实现的）\"]},\"53\":{\"h\":\"Spring中getBean的主体思路\",\"t\":[\"BeanFactory实现getBean方法在AbstractBeanFactory中，这个方法重载都是调用doGetBean方法进行实现的：\",\"public Object getBean(String name) throws BeansException { return doGetBean(name, null, null, false); } public <T> T getBean(String name, Class<T> requiredType) throws BeansException { return doGetBean(name, requiredType, null, false); } public Object getBean(String name, Object... args) throws BeansException { return doGetBean(name, null, args, false); } public <T> T getBean(String name, @Nullable Class<T> requiredType, @Nullable Object... args) throws BeansException { return doGetBean(name, requiredType, args, false); }\",\"我们来看下doGetBean方法(这个方法很长，我们主要看它的整体思路和设计要点）：\",\"// 参数typeCheckOnly：bean实例是否包含一个类型检查 protected <T> T doGetBean( String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException { // 解析bean的真正name，如果bean是工厂类，name前缀会加&，需要去掉 String beanName = transformedBeanName(name); Object beanInstance; // Eagerly check singleton cache for manually registered singletons. Object sharedInstance = getSingleton(beanName); if (sharedInstance != null && args == null) { // 无参单例从缓存中获取 beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, null); } else { // 如果bean实例还在创建中，则直接抛出异常 if (isPrototypeCurrentlyInCreation(beanName)) { throw new BeanCurrentlyInCreationException(beanName); } // 如果 bean definition 存在于父的bean工厂中，委派给父Bean工厂获取 BeanFactory parentBeanFactory = getParentBeanFactory(); if (parentBeanFactory != null && !containsBeanDefinition(beanName)) { // Not found -> check parent. String nameToLookup = originalBeanName(name); if (parentBeanFactory instanceof AbstractBeanFactory) { return ((AbstractBeanFactory) parentBeanFactory).doGetBean( nameToLookup, requiredType, args, typeCheckOnly); } else if (args != null) { // Delegation to parent with explicit args. return (T) parentBeanFactory.getBean(nameToLookup, args); } else if (requiredType != null) { // No args -> delegate to standard getBean method. return parentBeanFactory.getBean(nameToLookup, requiredType); } else { return (T) parentBeanFactory.getBean(nameToLookup); } } if (!typeCheckOnly) { // 将当前bean实例放入alreadyCreated集合里，标识这个bean准备创建了 markBeanAsCreated(beanName); } StartupStep beanCreation = this.applicationStartup.start(\\\"spring.beans.instantiate\\\") .tag(\\\"beanName\\\", name); try { if (requiredType != null) { beanCreation.tag(\\\"beanType\\\", requiredType::toString); } RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // 确保它的依赖也被初始化了. String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) { for (String dep : dependsOn) { if (isDependent(beanName, dep)) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \\\"Circular depends-on relationship between '\\\" + beanName + \\\"' and '\\\" + dep + \\\"'\\\"); } registerDependentBean(dep, beanName); try { getBean(dep); // 初始化它依赖的Bean } catch (NoSuchBeanDefinitionException ex) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \\\"'\\\" + beanName + \\\"' depends on missing bean '\\\" + dep + \\\"'\\\", ex); } } } // 创建Bean实例：单例 if (mbd.isSingleton()) { sharedInstance = getSingleton(beanName, () -> { try { // 真正创建bean的方法 return createBean(beanName, mbd, args); } catch (BeansException ex) { // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; } }); beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); } // 创建Bean实例：原型 else if (mbd.isPrototype()) { // It's a prototype -> create a new instance. Object prototypeInstance = null; try { beforePrototypeCreation(beanName); prototypeInstance = createBean(beanName, mbd, args); } finally { afterPrototypeCreation(beanName); } beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); } // 创建Bean实例：根据bean的scope创建 else { String scopeName = mbd.getScope(); if (!StringUtils.hasLength(scopeName)) { throw new IllegalStateException(\\\"No scope name defined for bean ´\\\" + beanName + \\\"'\\\"); } Scope scope = this.scopes.get(scopeName); if (scope == null) { throw new IllegalStateException(\\\"No Scope registered for scope name '\\\" + scopeName + \\\"'\\\"); } try { Object scopedInstance = scope.get(beanName, () -> { beforePrototypeCreation(beanName); try { return createBean(beanName, mbd, args); } finally { afterPrototypeCreation(beanName); } }); beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); } catch (IllegalStateException ex) { throw new ScopeNotActiveException(beanName, scopeName, ex); } } } catch (BeansException ex) { beanCreation.tag(\\\"exception\\\", ex.getClass().toString()); beanCreation.tag(\\\"message\\\", String.valueOf(ex.getMessage())); cleanupAfterBeanCreationFailure(beanName); throw ex; } finally { beanCreation.end(); } } return adaptBeanInstance(name, beanInstance, requiredType); }\",\"这段代码很长，主要看我加中文注释的方法即可。\",\"解析bean的真正name，如果bean是工厂类，name前缀会加&，需要去掉\",\"无参单例先从缓存中尝试获取\",\"如果bean实例还在创建中，则直接抛出异常\",\"如果bean definition 存在于父的bean工厂中，委派给父Bean工厂获取\",\"标记这个beanName的实例正在创建\",\"确保它的依赖也被初始化\",\"真正创建 \",\"单例时\",\"原型时\",\"根据bean的scope创建\"]},\"54\":{\"h\":\"重点：Spring如何解决循环依赖问题\",\"t\":[\"首先我们需要说明，Spring只是解决了单例模式下属性依赖的循环问题；Spring为了解决单例的循环依赖问题，使用了三级缓存。\"]},\"55\":{\"h\":\"Spring单例模式下的属性依赖\",\"t\":[\"先来看下这三级缓存\",\"/** Cache of singleton objects: bean name --> bean instance */ private final Map<String, Object> singletonObjects = new ConcurrentHashMap<String, Object>(256); /** Cache of early singleton objects: bean name --> bean instance */ private final Map<String, Object> earlySingletonObjects = new HashMap<String, Object>(16); /** Cache of singleton factories: bean name --> ObjectFactory */ private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<String, ObjectFactory<?>>(16);\",\"第一层缓存（singletonObjects）：单例对象缓存池，已经实例化并且属性赋值，这里的对象是成熟对象；\",\"第二层缓存（earlySingletonObjects）：单例对象缓存池，已经实例化但尚未属性赋值，这里的对象是半成品对象；\",\"第三层缓存（singletonFactories）: 单例工厂的缓存\",\"如下是获取单例中\",\"protected Object getSingleton(String beanName, boolean allowEarlyReference) { // Spring首先从singletonObjects（一级缓存）中尝试获取 Object singletonObject = this.singletonObjects.get(beanName); // 若是获取不到而且对象在建立中，则尝试从earlySingletonObjects(二级缓存)中获取 if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) { synchronized (this.singletonObjects) { singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null && allowEarlyReference) { ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) { //若是仍是获取不到而且容许从singletonFactories经过getObject获取，则经过singletonFactory.getObject()(三级缓存)获取 singletonObject = singletonFactory.getObject(); //若是获取到了则将singletonObject放入到earlySingletonObjects,也就是将三级缓存提高到二级缓存中 this.earlySingletonObjects.put(beanName, singletonObject); this.singletonFactories.remove(beanName); } } } } return (singletonObject != NULL_OBJECT ? singletonObject : null); }\",\"补充一些方法和参数\",\"isSingletonCurrentlyInCreation()：判断当前单例bean是否正在建立中，也就是没有初始化完成(好比A的构造器依赖了B对象因此得先去建立B对象， 或则在A的populateBean过程当中依赖了B对象，得先去建立B对象，这时的A就是处于建立中的状态。)\",\"allowEarlyReference ：是否容许从singletonFactories中经过getObject拿到对象\",\"分析getSingleton()的整个过程，Spring首先从一级缓存singletonObjects中获取。若是获取不到，而且对象正在建立中，就再从二级缓存earlySingletonObjects中获取。若是仍是获取不到且容许singletonFactories经过getObject()获取，就从三级缓存singletonFactory.getObject()(三级缓存)获取，若是获取到了则从三级缓存移动到了二级缓存。\",\"从上面三级缓存的分析，咱们能够知道，Spring解决循环依赖的诀窍就在于singletonFactories这个三级cache。这个cache的类型是ObjectFactory，定义以下：\",\"public interface ObjectFactory<T> { T getObject() throws BeansException; }\",\"在bean建立过程当中，有两处比较重要的匿名内部类实现了该接口。一处是Spring利用其建立bean的时候，另外一处就是:\",\"addSingletonFactory(beanName, new ObjectFactory<Object>() { @Override public Object getObject() throws BeansException { return getEarlyBeanReference(beanName, mbd, bean); }});\",\"此处就是解决循环依赖的关键，这段代码发生在createBeanInstance以后，也就是说单例对象此时已经被建立出来的。这个对象已经被生产出来了，虽然还不完美（尚未进行初始化的第二步和第三步），可是已经能被人认出来了（根据对象引用能定位到堆中的对象），因此Spring此时将这个对象提早曝光出来让你们认识，让你们使用。\",\"好比“A对象setter依赖B对象，B对象setter依赖A对象”，A首先完成了初始化的第一步，而且将本身提早曝光到singletonFactories中，此时进行初始化的第二步，发现本身依赖对象B，此时就尝试去get(B)，发现B尚未被create，因此走create流程，B在初始化第一步的时候发现本身依赖了对象A，因而尝试get(A)，尝试一级缓存singletonObjects(确定没有，由于A还没初始化彻底)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，因为A经过ObjectFactory将本身提早曝光了，因此B可以经过ObjectFactory.getObject拿到A对象(半成品)，B拿到A对象后顺利完成了初始化阶段一、二、三，彻底初始化以后将本身放入到一级缓存singletonObjects中。此时返回A中，A此时能拿到B的对象顺利完成本身的初始化阶段二、三，最终A也完成了初始化，进去了一级缓存singletonObjects中，并且更加幸运的是，因为B拿到了A的对象引用，因此B如今hold住的A对象完成了初始化。\"]},\"56\":{\"h\":\"Spring为何不能解决非单例属性之外的循环依赖？\",\"t\":[\"通过以下几个问题，辅助我们进一步理解。\"]},\"57\":{\"h\":\"Spring为什么不能解决构造器的循环依赖？\",\"t\":[\"构造器注入形成的循环依赖： 也就是beanB需要在beanA的构造函数中完成初始化，beanA也需要在beanB的构造函数中完成初始化，这种情况的结果就是两个bean都不能完成初始化，循环依赖难以解决。\",\"Spring解决循环依赖主要是依赖三级缓存，但是的在调用构造方法之前还未将其放入三级缓存之中，因此后续的依赖调用构造方法的时候并不能从三级缓存中获取到依赖的Bean，因此不能解决。\"]},\"58\":{\"h\":\"Spring为什么不能解决prototype作用域循环依赖？\",\"t\":[\"这种循环依赖同样无法解决，因为spring不会缓存‘prototype’作用域的bean，而spring中循环依赖的解决正是通过缓存来实现的。\"]},\"59\":{\"h\":\"Spring为什么不能解决多例的循环依赖？\",\"t\":[\"多实例Bean是每次调用一次getBean都会执行一次构造方法并且给属性赋值，根本没有三级缓存，因此不能解决循环依赖。\"]},\"60\":{\"h\":\"那么其它循环依赖如何解决？\",\"t\":[\"那么实际开发中，类似的依赖是如何解决？\",\"生成代理对象产生的循环依赖\",\"这类循环依赖问题解决方法很多，主要有：\",\"使用@Lazy注解，延迟加载\",\"使用@DependsOn注解，指定加载先后关系\",\"修改文件名称，改变循环依赖类的加载顺序\",\"使用@DependsOn产生的循环依赖\",\"这类循环依赖问题要找到@DependsOn注解循环依赖的地方，迫使它不循环依赖就可以解决问题。\",\"多例循环依赖\",\"这类循环依赖问题可以通过把bean改成单例的解决。\",\"构造器循环依赖\",\"这类循环依赖问题可以通过使用@Lazy注解解决。\"]},\"61\":{\"h\":\"重点：Spring中Bean的生命周期\",\"t\":[\"Spring 只帮我们管理单例模式 Bean 的完整生命周期，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。\",\"Spring 容器可以管理 singleton 作用域 Bean 的生命周期，在此作用域下，Spring 能够精确地知道该 Bean 何时被创建，何时初始化完成，以及何时被销毁。\",\"而对于 prototype 作用域的 Bean，Spring 只负责创建，当容器创建了 Bean 的实例后，Bean 的实例就交给客户端代码管理，Spring 容器将不再跟踪其生命周期。每次客户端请求 prototype 作用域的 Bean 时，Spring 容器都会创建一个新的实例，并且不会管那些被配置成 prototype 作用域的 Bean 的生命周期。\",\"了解 Spring 生命周期的意义就在于，可以利用 Bean 在其存活期间的指定时刻完成一些相关操作。这种时刻可能有很多，但一般情况下，会在 Bean 被初始化后和被销毁前执行一些相关操作。\"]},\"62\":{\"h\":\"Spring Bean生命周期流程\",\"t\":[\"在 Spring 中，Bean 的生命周期是一个很复杂的执行过程，我们可以利用 Spring 提供的方法定制 Bean 的创建过程。\",\"Spring 容器中 Bean 的生命周期流程\",\"如果 BeanFactoryPostProcessor 和 Bean 关联, 则调用postProcessBeanFactory方法.(即首先尝试从Bean工厂中获取Bean)\",\"如果 InstantiationAwareBeanPostProcessor 和 Bean 关联，则调用postProcessBeforeInstantiation方法\",\"根据配置情况调用 Bean 构造方法实例化 Bean。\",\"利用依赖注入完成 Bean 中所有属性值的配置注入。\",\"如果 InstantiationAwareBeanPostProcessor 和 Bean 关联，则调用postProcessAfterInstantiation方法和postProcessProperties\",\"调用xxxAware接口 (上图只是给了几个例子) \",\"第一类Aware接口\",\"如果 Bean 实现了 BeanNameAware 接口，则 Spring 调用 Bean 的 setBeanName() 方法传入当前 Bean 的 id 值。\",\"如果 Bean 实现了 BeanClassLoaderAware 接口，则 Spring 调用 setBeanClassLoader() 方法传入classLoader的引用。\",\"如果 Bean 实现了 BeanFactoryAware 接口，则 Spring 调用 setBeanFactory() 方法传入当前工厂实例的引用。\",\"第二类Aware接口\",\"如果 Bean 实现了 EnvironmentAware 接口，则 Spring 调用 setEnvironment() 方法传入当前 Environment 实例的引用。\",\"如果 Bean 实现了 EmbeddedValueResolverAware 接口，则 Spring 调用 setEmbeddedValueResolver() 方法传入当前 StringValueResolver 实例的引用。\",\"如果 Bean 实现了 ApplicationContextAware 接口，则 Spring 调用 setApplicationContext() 方法传入当前 ApplicationContext 实例的引用。\",\"...\",\"如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调用该接口的预初始化方法 postProcessBeforeInitialzation() 对 Bean 进行加工操作，此处非常重要，Spring 的 AOP 就是利用它实现的。\",\"如果 Bean 实现了 InitializingBean 接口，则 Spring 将调用 afterPropertiesSet() 方法。(或者有执行@PostConstruct注解的方法)\",\"如果在配置文件中通过 init-method 属性指定了初始化方法，则调用该初始化方法。\",\"如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调用该接口的初始化方法 postProcessAfterInitialization()。此时，Bean 已经可以被应用系统使用了。\",\"如果在 <bean> 中指定了该 Bean 的作用范围为 scope=\\\"singleton\\\"，则将该 Bean 放入 Spring IoC 的缓存池中，将触发 Spring 对该 Bean 的生命周期管理；如果在 <bean> 中指定了该 Bean 的作用范围为 scope=\\\"prototype\\\"，则将该 Bean 交给调用者，调用者管理该 Bean 的生命周期，Spring 不再管理该 Bean。\",\"如果 Bean 实现了 DisposableBean 接口，则 Spring 会调用 destory() 方法将 Spring 中的 Bean 销毁；(或者有执行@PreDestroy注解的方法)\",\"如果在配置文件中通过 destory-method 属性指定了 Bean 的销毁方法，则 Spring 将调用该方法对 Bean 进行销毁。\",\"Bean的完整生命周期经历了各种方法调用，这些方法可以划分为以下几类：(结合上图，需要有如下顶层思维)\",\"Bean自身的方法： 这个包括了Bean本身调用的方法和通过配置文件中<bean>的init-method和destroy-method指定的方法\",\"Bean级生命周期接口方法： 这个包括了BeanNameAware、BeanFactoryAware、ApplicationContextAware；当然也包括InitializingBean和DiposableBean这些接口的方法（可以被@PostConstruct和@PreDestroy注解替代)\",\"容器级生命周期接口方法： 这个包括了InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“后处理器”。\",\"工厂后处理器接口方法： 这个包括了AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer等等非常有用的工厂后处理器接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用。\"]},\"63\":{\"h\":\"Spring Bean生命周期案例\",\"t\":[\"我们通过一个例子来验证上面的整个流程\",\"定义Bean（这里是User）, 并让它实现BeanNameAware,BeanFactoryAware,ApplicationContextAware接口和InitializingBean,DisposableBean接口：\",\"package tech.pdai.springframework.entity; import lombok.ToString; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.BeansException; import org.springframework.beans.factory.BeanFactory; import org.springframework.beans.factory.BeanFactoryAware; import org.springframework.beans.factory.BeanNameAware; import org.springframework.beans.factory.DisposableBean; import org.springframework.beans.factory.InitializingBean; import org.springframework.context.ApplicationContext; import org.springframework.context.ApplicationContextAware; /** * @author pdai */ @Slf4j @ToString public class User implements BeanFactoryAware, BeanNameAware, ApplicationContextAware, InitializingBean, DisposableBean { /** * user's name. */ private String name; /** * user's age. */ private int age; /** * bean factory. */ private BeanFactory beanFactory; /** * application context. */ private ApplicationContext applicationContext; /** * bean name. */ private String beanName; public User() { log.info(\\\"execute User#new User()\\\"); } public void setName(String name) { log.info(\\\"execute User#setName({})\\\", name); this.name = name; } public void setAge(int age) { log.info(\\\"execute User#setAge({})\\\", age); this.age = age; } @Override public void setBeanFactory(BeanFactory beanFactory) throws BeansException { log.info(\\\"execute BeanFactoryAware#setBeanFactory\\\"); this.beanFactory = beanFactory; } @Override public void setBeanName(String s) { log.info(\\\"execute BeanNameAware#setBeanName\\\"); this.beanName = s; } @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { log.info(\\\"execute ApplicationContextAware#setApplicationContext\\\"); this.applicationContext = applicationContext; } @Override public void destroy() throws Exception { log.info(\\\"execute DisposableBean#destroy\\\"); } @Override public void afterPropertiesSet() throws Exception { log.info(\\\"execute InitializingBean#afterPropertiesSet\\\"); } public void doInit() { log.info(\\\"execute User#doInit\\\"); } public void doDestroy() { log.info(\\\"execute User#doDestroy\\\"); } }\",\"定义BeanFactoryPostProcessor的实现类\",\"/** * @author pdai */ @Slf4j @Component public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor { @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException { log.info(\\\"execute BeanFactoryPostProcessor#postProcessBeanFactory\\\"); } }\",\"定义InstantiationAwareBeanPostProcessor的实现类\",\"/** * @author pdai */ @Slf4j @Component public class MyInstantiationAwareBeanPostProcessor implements InstantiationAwareBeanPostProcessor { @Override public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException { log.info(\\\"execute InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation for {}\\\", beanName); return InstantiationAwareBeanPostProcessor.super.postProcessBeforeInstantiation(beanClass, beanName); } @Override public boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException { log.info(\\\"execute InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation for {}\\\", beanName); return InstantiationAwareBeanPostProcessor.super.postProcessAfterInstantiation(bean, beanName); } @Override public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) throws BeansException { log.info(\\\"execute InstantiationAwareBeanPostProcessor#postProcessProperties for {}\\\", beanName); return InstantiationAwareBeanPostProcessor.super.postProcessProperties(pvs, bean, beanName); } }\",\"定义BeanPostProcessor的实现类\",\"/** * @author pdai */ @Slf4j @Component public class MyBeanPostProcessor implements BeanPostProcessor { @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { log.info(\\\"execute BeanPostProcessor#postProcessBeforeInitialization for {}\\\", beanName); return BeanPostProcessor.super.postProcessBeforeInitialization(bean, beanName); } @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { log.info(\\\"execute BeanPostProcessor#postProcessAfterInitialization for {}\\\", beanName); return BeanPostProcessor.super.postProcessAfterInitialization(bean, beanName); } }\",\"通过Java配置方式初始化Bean\",\"/** * @author pdai */ @Configuration public class BeansConfig { @Bean(name = \\\"user\\\", initMethod = \\\"doInit\\\", destroyMethod = \\\"doDestroy\\\") public User create() { User user = new User(); user.setName(\\\"pdai\\\"); user.setAge(18); return user; } }\",\"测试的主方法\",\"/** * Cglib proxy demo. * * @author pdai */ @Slf4j public class App { /** * main interface. * * @param args args */ public static void main(String[] args) { log.info(\\\"Init application context\\\"); // create and configure beans AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext( \\\"tech.pdai.springframework\\\"); // retrieve configured instance User user = (User) context.getBean(\\\"user\\\"); // print info from beans log.info(user.toString()); log.info(\\\"Shutdown application context\\\"); context.registerShutdownHook(); } }\",\"输出结果（剔除无关输出）：\",\"12:44:42.547 [main] INFO tech.pdai.springframework.App - Init application context ... 12:44:43.134 [main] INFO tech.pdai.springframework.processor.MyBeanFactoryPostProcessor - execute BeanFactoryPostProcessor#postProcessBeanFactory ... 12:44:43.216 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'user' 12:44:43.216 [main] INFO tech.pdai.springframework.processor.MyInstantiationAwareBeanPostProcessor - execute InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation for user 12:44:43.236 [main] INFO tech.pdai.springframework.entity.User - execute User#new User() 12:44:43.237 [main] INFO tech.pdai.springframework.entity.User - execute User#setName(pdai) 12:44:43.237 [main] INFO tech.pdai.springframework.entity.User - execute User#setAge(18) 12:44:43.237 [main] INFO tech.pdai.springframework.processor.MyInstantiationAwareBeanPostProcessor - execute InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation for user 12:44:43.237 [main] INFO tech.pdai.springframework.processor.MyInstantiationAwareBeanPostProcessor - execute InstantiationAwareBeanPostProcessor#postProcessProperties for user 12:44:43.242 [main] INFO tech.pdai.springframework.entity.User - execute BeanNameAware#setBeanName 12:44:43.242 [main] INFO tech.pdai.springframework.entity.User - execute BeanFactoryAware#setBeanFactory 12:44:43.242 [main] INFO tech.pdai.springframework.entity.User - execute ApplicationContextAware#setApplicationContext 12:44:43.242 [main] INFO tech.pdai.springframework.processor.MyBeanPostProcessor - execute BeanPostProcessor#postProcessBeforeInitialization for user 12:44:43.242 [main] INFO tech.pdai.springframework.entity.User - execute InitializingBean#afterPropertiesSet 12:44:43.243 [main] INFO tech.pdai.springframework.entity.User - execute User#doInit 12:44:43.243 [main] INFO tech.pdai.springframework.processor.MyBeanPostProcessor - execute BeanPostProcessor#postProcessAfterInitialization for user 12:44:43.270 [main] INFO tech.pdai.springframework.App - User(name=pdai, age=18) 12:44:43.270 [main] INFO tech.pdai.springframework.App - Shutdown application context 12:44:43.276 [SpringContextShutdownHook] INFO tech.pdai.springframework.entity.User - execute DisposableBean#destroy 12:44:43.276 [SpringContextShutdownHook] INFO tech.pdai.springframework.entity.User - execute User#doDestroy\"]},\"64\":{\"h\":\"Spring Bean生命周期源码\"},\"65\":{\"h\":\"参考文章\",\"t\":[\"https://juejin.cn/post/6844903843596107790\",\"https://www.zhihu.com/question/438247718/answer/1730527725\"]},\"66\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"67\":{\"h\":\"Posts\"},\"68\":{\"h\":\"Java 基础\"},\"69\":{\"h\":\"Java\"},\"70\":{\"h\":\"Spring\"},\"71\":{\"h\":\"框架\"},\"72\":{\"h\":\"数据结构知识体系\"},\"73\":{\"h\":\"算法\"},\"74\":{\"h\":\"AOP\"},\"75\":{\"h\":\"IOC\"}},\"dirtCount\":0,\"index\":[[\"算法\",{\"0\":{\"73\":1}}],[\"算法之道在新窗口打开\",{\"1\":{\"41\":1}}],[\"算法之道\",{\"1\":{\"41\":1}}],[\"框架\",{\"0\":{\"71\":1}}],[\"question\",{\"1\":{\"65\":1}}],[\"qg\",{\"1\":{\"40\":2}}],[\"zhihu\",{\"1\":{\"65\":1}}],[\"404\",{\"1\":{\"66\":1}}],[\"403\",{\"0\":{\"15\":1},\"1\":{\"15\":1}}],[\"438247718\",{\"1\":{\"65\":1}}],[\"43\",{\"1\":{\"63\":19}}],[\"42\",{\"1\":{\"63\":1}}],[\"44\",{\"1\":{\"63\":20}}],[\"剔除无关输出\",{\"1\":{\"63\":1}}],[\"输出结果\",{\"1\":{\"63\":1}}],[\"输入命令\",{\"1\":{\"17\":1}}],[\"输入一个你喜欢的\",{\"1\":{\"11\":1}}],[\"定义instantiationawarebeanpostprocessor的实现类\",{\"1\":{\"63\":1}}],[\"定义beanpostprocessor的实现类\",{\"1\":{\"63\":1}}],[\"定义beanfactorypostprocessor的实现类\",{\"1\":{\"63\":1}}],[\"定义bean\",{\"1\":{\"63\":1}}],[\"定义以下\",{\"1\":{\"55\":1}}],[\"工厂后处理器也是容器级的\",{\"1\":{\"62\":1}}],[\"工厂后处理器接口方法\",{\"1\":{\"62\":1}}],[\"工具\",{\"2\":{\"22\":1}}],[\"结合上图\",{\"1\":{\"62\":1}}],[\"结构之法\",{\"1\":{\"41\":1}}],[\"销毁\",{\"1\":{\"62\":1}}],[\"交给调用者\",{\"1\":{\"62\":1}}],[\"交给子类拓展\",{\"1\":{\"46\":1}}],[\"放入\",{\"1\":{\"62\":1}}],[\"已经可以被应用系统使用了\",{\"1\":{\"62\":1}}],[\"已经实例化但尚未属性赋值\",{\"1\":{\"55\":1}}],[\"已经实例化并且属性赋值\",{\"1\":{\"55\":1}}],[\"调用者管理该\",{\"1\":{\"62\":1}}],[\"调用\",{\"1\":{\"62\":6}}],[\"调用xxxaware接口\",{\"1\":{\"62\":1}}],[\"被初始化后和被销毁前执行一些相关操作\",{\"1\":{\"61\":1}}],[\"了解\",{\"1\":{\"61\":1}}],[\"当然也包括initializingbean和diposablebean这些接口的方法\",{\"1\":{\"62\":1}}],[\"当容器创建了\",{\"1\":{\"61\":1}}],[\"当设置proxy\",{\"1\":{\"48\":1}}],[\"何时初始化完成\",{\"1\":{\"61\":1}}],[\"何时被创建\",{\"1\":{\"61\":1}}],[\"能够精确地知道该\",{\"1\":{\"61\":1}}],[\"能提升网站美观度和趣味性\",{\"1\":{\"6\":1}}],[\"迫使它不循环依赖就可以解决问题\",{\"1\":{\"60\":1}}],[\"改变循环依赖类的加载顺序\",{\"1\":{\"60\":1}}],[\"改为\",{\"1\":{\"11\":1}}],[\"延迟加载\",{\"1\":{\"60\":1}}],[\"根本没有三级缓存\",{\"1\":{\"59\":1}}],[\"根据配置情况调用\",{\"1\":{\"62\":1}}],[\"根据对象引用能定位到堆中的对象\",{\"1\":{\"55\":1}}],[\"根据bean的scope创建\",{\"1\":{\"53\":2}}],[\"根据bean的名字和class类型等来得到bean实例\",{\"1\":{\"51\":1}}],[\"根据bean生命周期方法找到两个核心方法\",{\"1\":{\"44\":1}}],[\"作用域的\",{\"1\":{\"61\":3}}],[\"作用域的bean\",{\"1\":{\"58\":1}}],[\"作用域\",{\"1\":{\"61\":1}}],[\"作为国内节点\",{\"1\":{\"9\":1}}],[\"循环依赖难以解决\",{\"1\":{\"57\":1}}],[\"循环依赖等\",{\"0\":{\"49\":1},\"1\":{\"38\":1,\"49\":1,\"52\":1}}],[\"辅助我们进一步理解\",{\"1\":{\"56\":1}}],[\"彻底初始化以后将本身放入到一级缓存singletonobjects中\",{\"1\":{\"55\":1}}],[\"半成品\",{\"1\":{\"55\":1}}],[\"尝试三级缓存singletonfactories\",{\"1\":{\"55\":1}}],[\"尝试二级缓存earlysingletonobjects\",{\"1\":{\"55\":1}}],[\"尝试一级缓存singletonobjects\",{\"1\":{\"55\":1}}],[\"发现b尚未被create\",{\"1\":{\"55\":1}}],[\"发现本身依赖对象b\",{\"1\":{\"55\":1}}],[\"好比\",{\"1\":{\"55\":1}}],[\"好比a的构造器依赖了b对象因此得先去建立b对象\",{\"1\":{\"55\":1}}],[\"让你们使用\",{\"1\":{\"55\":1}}],[\"尚未进行初始化的第二步和第三步\",{\"1\":{\"55\":1}}],[\"虽然还不完美\",{\"1\":{\"55\":1}}],[\"另外一处就是\",{\"1\":{\"55\":1}}],[\"咱们能够知道\",{\"1\":{\"55\":1}}],[\"得先去建立b对象\",{\"1\":{\"55\":1}}],[\"判断当前单例bean是否正在建立中\",{\"1\":{\"55\":1}}],[\"补充一些方法和参数\",{\"1\":{\"55\":1}}],[\"获取\",{\"1\":{\"55\":3}}],[\"获取所有切面类的切面方法生成advisor\",{\"1\":{\"46\":2}}],[\"获取所有advisor后\",{\"1\":{\"47\":1}}],[\"获取所有advisor\",{\"1\":{\"45\":1}}],[\"获取所有的advisor\",{\"0\":{\"46\":1},\"1\":{\"43\":1}}],[\"三\",{\"1\":{\"55\":2}}],[\"三级缓存\",{\"1\":{\"55\":2}}],[\"三大特性\",{\"0\":{\"25\":1},\"1\":{\"24\":1}}],[\"一般称它们的实现类为\",{\"1\":{\"62\":1}}],[\"一处是spring利用其建立bean的时候\",{\"1\":{\"55\":1}}],[\"一级缓存\",{\"1\":{\"55\":1}}],[\"一个学校可以有很多学生\",{\"1\":{\"34\":1}}],[\"第二类aware接口\",{\"1\":{\"62\":1}}],[\"第二层缓存\",{\"1\":{\"55\":1}}],[\"第一类aware接口\",{\"1\":{\"62\":1}}],[\"第一层缓存\",{\"1\":{\"55\":1}}],[\"第三层缓存\",{\"1\":{\"55\":1}}],[\"先来看下这三级缓存\",{\"1\":{\"55\":1}}],[\"真正创建\",{\"1\":{\"53\":1}}],[\"真正创建bean的方法\",{\"1\":{\"53\":1}}],[\"无参单例先从缓存中尝试获取\",{\"1\":{\"53\":1}}],[\"无参单例从缓存中获取\",{\"1\":{\"53\":1}}],[\"´\",{\"1\":{\"53\":1}}],[\"原型时\",{\"1\":{\"53\":1}}],[\"原型\",{\"1\":{\"53\":1}}],[\"原则在新窗口打开\",{\"1\":{\"36\":1}}],[\"原则\",{\"1\":{\"36\":1}}],[\"单例工厂的缓存\",{\"1\":{\"55\":1}}],[\"单例对象缓存池\",{\"1\":{\"55\":2}}],[\"单例时\",{\"1\":{\"53\":1}}],[\"单例\",{\"1\":{\"53\":1}}],[\"单词查找树或键树\",{\"1\":{\"39\":1}}],[\"确定没有\",{\"1\":{\"55\":1}}],[\"确定一个链表我们只需要头指针\",{\"1\":{\"39\":1}}],[\"确保它的依赖也被初始化\",{\"1\":{\"53\":1}}],[\"确保它的依赖也被初始化了\",{\"1\":{\"53\":1}}],[\"标记这个beanname的实例正在创建\",{\"1\":{\"53\":1}}],[\"标识这个bean准备创建了\",{\"1\":{\"53\":1}}],[\"标签\",{\"1\":{\"2\":1}}],[\"委派给父bean工厂获取\",{\"1\":{\"53\":2}}],[\"存在于父的bean工厂中\",{\"1\":{\"53\":2}}],[\"存放记录的数组叫做散列表\",{\"1\":{\"39\":1}}],[\"构造方法实例化\",{\"1\":{\"62\":1}}],[\"构造器循环依赖\",{\"1\":{\"60\":1}}],[\"构造器注入形成的循环依赖\",{\"1\":{\"57\":1}}],[\"构造函数从beandefinition的getconstructorargumentvalues\",{\"1\":{\"52\":1}}],[\"构建了\",{\"1\":{\"1\":1}}],[\"\\b以及spring如何实现将资源配置\",{\"1\":{\"50\":1}}],[\"初始化它依赖的bean\",{\"1\":{\"53\":1}}],[\"初步的思考\",{\"0\":{\"52\":1},\"1\":{\"49\":1}}],[\"初衷\",{\"0\":{\"1\":1}}],[\"几个要点\",{\"1\":{\"48\":1}}],[\"几十秒后\",{\"1\":{\"11\":1}}],[\"||\",{\"1\":{\"45\":1,\"48\":3}}],[\"|──\",{\"1\":{\"5\":2}}],[\"主要有\",{\"1\":{\"60\":1}}],[\"主要看我加中文注释的方法即可\",{\"1\":{\"53\":1}}],[\"主要负责将advisor注入到合适的位置\",{\"1\":{\"44\":1}}],[\"主要是处理使用了\",{\"1\":{\"44\":1}}],[\"主题和插件\",{\"1\":{\"5\":1}}],[\"由于a还没初始化彻底\",{\"1\":{\"55\":1}}],[\"由于beandefinition还有单例的信息\",{\"1\":{\"52\":1}}],[\"由于读书笔记架构更换到\",{\"1\":{\"7\":1}}],[\"由此我们可以知道\",{\"1\":{\"48\":1}}],[\"由ioc\",{\"1\":{\"44\":1}}],[\"加载配置\",{\"1\":{\"44\":1}}],[\"加入到以下两个文件\",{\"1\":{\"6\":1}}],[\"依据条件创建代理\",{\"0\":{\"48\":1},\"1\":{\"43\":1}}],[\"依赖关系是在运行过程中起作用的\",{\"1\":{\"35\":1}}],[\"依赖关系\",{\"0\":{\"35\":1},\"1\":{\"24\":1}}],[\"81431354\",{\"1\":{\"42\":1}}],[\"8039007\",{\"1\":{\"42\":1}}],[\"8080\",{\"1\":{\"17\":1}}],[\"亦海\",{\"1\":{\"40\":1}}],[\"亦海数据结构的文章\",{\"1\":{\"40\":1}}],[\"写的很清晰\",{\"1\":{\"40\":1}}],[\"推荐\",{\"1\":{\"40\":3}}],[\"推荐github上java算法集合\",{\"1\":{\"40\":1}}],[\"推荐一个学习数据结构的英文网站\",{\"1\":{\"40\":1}}],[\"推送到\",{\"1\":{\"9\":1}}],[\"强烈推荐用动画学习算法\",{\"1\":{\"40\":1}}],[\"问题\",{\"1\":{\"39\":1}}],[\"路由选择等\",{\"1\":{\"39\":1}}],[\"路径\",{\"1\":{\"13\":1}}],[\"路径下\",{\"1\":{\"8\":2}}],[\"路径下的\",{\"1\":{\"6\":1}}],[\"路径下是网站的配置文件\",{\"1\":{\"5\":1}}],[\"公交查询系统\",{\"1\":{\"39\":1}}],[\"公司没了部门就不存在了\",{\"1\":{\"33\":1}}],[\"横向优先搜索\",{\"1\":{\"39\":1}}],[\"宽度优先搜索\",{\"1\":{\"39\":1}}],[\"广度优先搜索算法\",{\"1\":{\"39\":1}}],[\"遍历\",{\"1\":{\"39\":1}}],[\"分析getsingleton\",{\"1\":{\"55\":1}}],[\"分析计算机网络的拓扑结构确定两台计算机是否可以通信\",{\"1\":{\"39\":1}}],[\"分支\",{\"1\":{\"3\":1}}],[\"分支设置为\",{\"1\":{\"3\":1}}],[\"化学上用图区分结构不同但分子式相同的同分异构体\",{\"1\":{\"39\":1}}],[\"人与人之间的社交与关系网络\",{\"1\":{\"39\":1}}],[\"拓扑排序主要用来解决有向图中的依赖解析\",{\"1\":{\"39\":1}}],[\"拓扑排序\",{\"1\":{\"39\":2}}],[\"kruskal算法是从最小权重边着手\",{\"1\":{\"39\":1}}],[\"kruskal\",{\"1\":{\"39\":2}}],[\"key\",{\"1\":{\"39\":1,\"45\":1}}],[\"keyboard\",{\"1\":{\"32\":2}}],[\"图的深度优先搜索\",{\"1\":{\"39\":1}}],[\"图的遍历\",{\"1\":{\"39\":1}}],[\"图是最灵活的数据结构之一\",{\"1\":{\"39\":1}}],[\"图基础\",{\"1\":{\"39\":1}}],[\"图\",{\"1\":{\"39\":8}}],[\"图片链接\",{\"1\":{\"8\":1}}],[\"查询效率比哈希树高\",{\"1\":{\"39\":1}}],[\"查找就退化成节点内部的线性查找了\",{\"1\":{\"39\":1}}],[\"最终a也完成了初始化\",{\"1\":{\"55\":1}}],[\"最终的将bean的定义即beandefinition放到beandefinitionmap中\",{\"1\":{\"52\":1}}],[\"最短路径有着广泛的应用\",{\"1\":{\"39\":1}}],[\"最短路径\",{\"1\":{\"39\":2}}],[\"最小生成树\",{\"1\":{\"39\":2}}],[\"最小二叉平衡树的节点的公式如下\",{\"1\":{\"39\":1}}],[\"最后理解数据结构中逻辑结构之图\",{\"1\":{\"39\":1}}],[\"最大限度地减少无谓的字符串比较\",{\"1\":{\"39\":1}}],[\"利用依赖注入完成\",{\"1\":{\"62\":1}}],[\"利用字符串的公共前缀来减少查询时间\",{\"1\":{\"39\":1}}],[\"利用抽象数据类型将数据和基于数据的操作封装在一起\",{\"1\":{\"26\":1}}],[\"排序和保存大量的字符串\",{\"1\":{\"39\":1}}],[\"典型应用是用于统计\",{\"1\":{\"39\":1}}],[\"典型的用途是实现关联数组\",{\"1\":{\"39\":1}}],[\"276\",{\"1\":{\"63\":2}}],[\"270\",{\"1\":{\"63\":2}}],[\"243\",{\"1\":{\"63\":2}}],[\"242\",{\"1\":{\"63\":5}}],[\"237\",{\"1\":{\"63\":4}}],[\"236\",{\"1\":{\"63\":1}}],[\"216\",{\"1\":{\"63\":2}}],[\"256\",{\"1\":{\"55\":1}}],[\"2\",{\"1\":{\"39\":2}}],[\"2提高到2\",{\"1\":{\"39\":1}}],[\"伸展树等\",{\"1\":{\"39\":1}}],[\"替罪羊树\",{\"1\":{\"39\":1}}],[\"替换为你的博客域名\",{\"1\":{\"7\":1}}],[\"具体如下\",{\"1\":{\"44\":1}}],[\"具体方法可以参考页面底部的常见问题\",{\"1\":{\"3\":1}}],[\"具有以下性质\",{\"1\":{\"39\":1}}],[\"右子树也分别为二叉排序树\",{\"1\":{\"39\":1}}],[\"又称为\",{\"1\":{\"39\":1}}],[\"又称字典树\",{\"1\":{\"39\":1}}],[\"又\",{\"1\":{\"39\":1}}],[\"前提\",{\"1\":{\"39\":1}}],[\"前缀树\",{\"1\":{\"39\":2}}],[\"前文主要spring\",{\"1\":{\"44\":1}}],[\"前文我们有了ioc的源码基础以及springmvc的基础\",{\"1\":{\"38\":2}}],[\"前文我们介绍了spring框架和spring框架中最为重要的两个技术点\",{\"1\":{\"38\":1}}],[\"前文\",{\"1\":{\"38\":1}}],[\"哈夫曼又称最优二叉树\",{\"1\":{\"39\":1}}],[\"哈夫曼树\",{\"1\":{\"39\":2}}],[\"哈希表\",{\"1\":{\"39\":1}}],[\"哈希表是数组和链表的折中\",{\"1\":{\"39\":1}}],[\"红黑树\",{\"1\":{\"39\":3}}],[\"红黑树是平衡二叉树和avl树的折中\",{\"1\":{\"39\":1}}],[\"平衡二叉树的常用实现方法有红黑树\",{\"1\":{\"39\":1}}],[\"平衡二叉树\",{\"1\":{\"39\":3}}],[\"逻辑结构\",{\"1\":{\"39\":2}}],[\"栈和队列都是线性存储结构的应用\",{\"1\":{\"39\":1}}],[\"栈和队列\",{\"1\":{\"39\":1}}],[\"栈和队列等\",{\"1\":{\"39\":1}}],[\"散列表\",{\"1\":{\"39\":1}}],[\"散列\",{\"1\":{\"39\":1}}],[\"尾节点没有后续节点\",{\"1\":{\"39\":1}}],[\"首推\",{\"1\":{\"41\":1}}],[\"首节点没有前驱节点\",{\"1\":{\"39\":1}}],[\"首先我们需要说明\",{\"1\":{\"54\":1}}],[\"首先理解数据结构中线性结构及其延伸\",{\"1\":{\"39\":1}}],[\"首先\",{\"1\":{\"3\":1,\"38\":1}}],[\"彼此通过指针相连\",{\"1\":{\"39\":1}}],[\"大小相等\",{\"1\":{\"39\":1}}],[\"大部分情况下\",{\"1\":{\"3\":1}}],[\"元素类型相同\",{\"1\":{\"39\":1}}],[\"线性表\",{\"1\":{\"39\":4}}],[\"线性结构\",{\"1\":{\"39\":1}}],[\"链表\",{\"1\":{\"39\":2}}],[\"链表也不适合查找\",{\"1\":{\"39\":1}}],[\"任何进阶都逃不开这些知识点\",{\"1\":{\"39\":1}}],[\"任何一种数组无法解决的问题就是插入\",{\"1\":{\"39\":1}}],[\"都与这有关\",{\"1\":{\"39\":1}}],[\"正则表达式\",{\"1\":{\"39\":1}}],[\"什么模式匹配\",{\"1\":{\"39\":1}}],[\"还有很多变体\",{\"1\":{\"39\":1}}],[\"很多问题都可以使用图模型进行建模求解\",{\"1\":{\"39\":1}}],[\"很多字符串处理任务都会用到\",{\"1\":{\"39\":1}}],[\"很多人选择使用\",{\"1\":{\"9\":1}}],[\"矩形和多边形这类多维数据建立索引\",{\"1\":{\"39\":1}}],[\"3\",{\"1\":{\"39\":1}}],[\"38173324\",{\"1\":{\"36\":1}}],[\"树在数据结构中至关重要\",{\"1\":{\"39\":1}}],[\"树\",{\"1\":{\"39\":7}}],[\"树是b+树的变体\",{\"1\":{\"39\":1}}],[\"树节点存储的元素数量是有限的\",{\"1\":{\"39\":1}}],[\"通常用于关系型数据库\",{\"1\":{\"39\":1}}],[\"通过java配置方式初始化bean\",{\"1\":{\"63\":1}}],[\"通过以下几个问题\",{\"1\":{\"56\":1}}],[\"通过反射初始化beanclassname的实例instance\",{\"1\":{\"52\":1}}],[\"通过introduction实现的advice\",{\"1\":{\"46\":1}}],[\"通过findeligibleadvisors方法获取advisor\",{\"1\":{\"46\":1}}],[\"通过aspectjawareadvisorautoproxycreator类去创建\",{\"1\":{\"44\":1}}],[\"通过头指针就可以把整个链表都能推出来\",{\"1\":{\"39\":1}}],[\"通过使用整型索引值来访问他们的元素\",{\"1\":{\"39\":1}}],[\"通过加载\",{\"1\":{\"38\":2,\"49\":1,\"50\":1}}],[\"通过案例引出spring的核心\",{\"1\":{\"38\":1}}],[\"通过正确配置\",{\"1\":{\"13\":1}}],[\"通过\",{\"1\":{\"9\":1}}],[\"所以我们来看下spring是如何是如何实现的\",{\"1\":{\"52\":1}}],[\"所以经常被搜索引擎系统用于文本词频统计\",{\"1\":{\"39\":1}}],[\"所以也不适合大规模的查找\",{\"1\":{\"39\":1}}],[\"所有关键字都在叶子结点\",{\"1\":{\"39\":1}}],[\"是通过<aop\",{\"1\":{\"48\":1}}],[\"是通过optimize设置\",{\"1\":{\"48\":1}}],[\"是否容许从singletonfactories中经过getobject拿到对象\",{\"1\":{\"55\":1}}],[\"是否能够应用于clazz的advice\",{\"1\":{\"46\":1}}],[\"是否跳过\",{\"1\":{\"45\":1}}],[\"是否屏蔽了\",{\"1\":{\"14\":1}}],[\"是由顶点和连接顶点的边构成的离散结构\",{\"1\":{\"39\":1}}],[\"是一种哈希树的变种\",{\"1\":{\"39\":1}}],[\"是一种树形结构\",{\"1\":{\"39\":1}}],[\"是一种带权路径长度最短的二叉树\",{\"1\":{\"39\":1}}],[\"是一种自平衡二叉查找树\",{\"1\":{\"39\":1}}],[\"是平衡二叉树和avl树的折中\",{\"1\":{\"39\":1}}],[\"是在计算机科学中用到的一种数据结构\",{\"1\":{\"39\":1}}],[\"是右子树的节点数量\",{\"1\":{\"39\":1}}],[\"是左子树的节点数量\",{\"1\":{\"39\":1}}],[\"是根据关键码值\",{\"1\":{\"39\":1}}],[\"是大规模数据存储中\",{\"1\":{\"39\":1}}],[\"集合类中的map\",{\"1\":{\"39\":1}}],[\"集成了看板娘\",{\"1\":{\"6\":1}}],[\"二\",{\"1\":{\"55\":1}}],[\"二级缓存\",{\"1\":{\"55\":1}}],[\"二叉排序树\",{\"1\":{\"39\":1}}],[\"二叉树中最基本的二叉查找树\",{\"1\":{\"39\":1}}],[\"二叉搜索树\",{\"1\":{\"39\":3}}],[\"二叉查找树因为可能退化成链表\",{\"1\":{\"39\":1}}],[\"二分法查找解决了普通数组查找复杂度过高的问题\",{\"1\":{\"39\":1}}],[\"二分查找要求数组的构造一定有序\",{\"1\":{\"39\":1}}],[\"普通链表由于它的结构特点被证明根本不适合进行查找\",{\"1\":{\"39\":1}}],[\"删除操作比较复杂\",{\"1\":{\"39\":1}}],[\"实例的引用\",{\"1\":{\"62\":3}}],[\"实例化出bean对象\",{\"1\":{\"50\":1}}],[\"实现了\",{\"1\":{\"62\":8}}],[\"实现索引查询这样一个实际背景下\",{\"1\":{\"39\":1}}],[\"实现关系\",{\"0\":{\"31\":1},\"1\":{\"24\":1}}],[\"实际应用当中的数据往往十分庞大\",{\"1\":{\"39\":1}}],[\"故数组的长度也是有限的\",{\"1\":{\"39\":1}}],[\"十分常用\",{\"1\":{\"39\":1}}],[\"操作系统等当中\",{\"1\":{\"39\":1}}],[\"避免孤立的学习知识点\",{\"1\":{\"39\":1}}],[\"避免因权限不足导致部署失败\",{\"1\":{\"3\":1}}],[\"学习思路\",{\"1\":{\"39\":1}}],[\"入门推荐\",{\"0\":{\"40\":1},\"1\":{\"39\":1}}],[\"知识点\",{\"1\":{\"39\":1}}],[\"知识体系系统性梳理\",{\"1\":{\"39\":1}}],[\"知识体系\",{\"1\":{\"39\":2}}],[\"知识库\",{\"1\":{\"1\":1}}],[\"性能及适用场景\",{\"1\":{\"39\":1}}],[\"要关联学习\",{\"1\":{\"39\":1}}],[\"要了解算法思想\",{\"1\":{\"39\":1}}],[\"要解决这个问题\",{\"1\":{\"15\":1}}],[\"格局要大一点\",{\"1\":{\"39\":1}}],[\"♥数据结构基础知识体系详解♥\",{\"0\":{\"39\":1}}],[\"♥spring框架知识体系详解♥\",{\"0\":{\"37\":1}}],[\"包含dispatcherservlet的初始化过程和dispatcherservlet处理请求的过程的源码解析\",{\"1\":{\"38\":2}}],[\"代理的创建\",{\"0\":{\"45\":1},\"1\":{\"43\":1}}],[\"代理\",{\"1\":{\"38\":1,\"43\":1}}],[\"代码块\",{\"1\":{\"7\":1}}],[\"代码编程\",{\"1\":{\"2\":1}}],[\"容器级生命周期接口方法\",{\"1\":{\"62\":1}}],[\"容器中\",{\"1\":{\"62\":1}}],[\"容器中存放的是bean的定义即beandefinition放到beandefinitionmap中\",{\"1\":{\"38\":1,\"49\":1,\"50\":1}}],[\"容器都会创建一个新的实例\",{\"1\":{\"61\":1}}],[\"容器将不再跟踪其生命周期\",{\"1\":{\"61\":1}}],[\"容器可以管理\",{\"1\":{\"61\":1}}],[\"容器为主\",{\"1\":{\"2\":1}}],[\"生成代理对象产生的循环依赖\",{\"1\":{\"60\":1}}],[\"生成beandefination并注册到ioc容器中的\",{\"1\":{\"38\":2,\"49\":1,\"50\":1}}],[\"生态环境中不同物种的相互竞争\",{\"1\":{\"39\":1}}],[\"生命周期的意义就在于\",{\"1\":{\"61\":1}}],[\"生命周期\",{\"0\":{\"49\":1},\"1\":{\"38\":1,\"49\":1}}],[\"生活记录和小技巧\",{\"1\":{\"2\":1}}],[\"生活角落\",{\"1\":{\"2\":1}}],[\"解析bean的真正name\",{\"1\":{\"53\":2}}],[\"解析\",{\"1\":{\"38\":2,\"49\":1,\"50\":1}}],[\"解决步骤如下\",{\"1\":{\"13\":1}}],[\"紧接着这篇\",{\"1\":{\"38\":1}}],[\"目的是为了简化java栈的web开发\",{\"1\":{\"38\":1}}],[\"目录下\",{\"1\":{\"7\":1}}],[\"目录结构如下\",{\"1\":{\"5\":1}}],[\"遵循上述web\",{\"1\":{\"38\":1}}],[\"那说明不要进行增强\",{\"1\":{\"45\":1}}],[\"那我们如何更好的构建上层的应用呢\",{\"1\":{\"38\":1}}],[\"那么实际开发中\",{\"1\":{\"60\":1}}],[\"那么其它循环依赖如何解决\",{\"0\":{\"60\":1},\"1\":{\"49\":1}}],[\"那么动态代理是如何工作的呢\",{\"1\":{\"38\":1}}],[\"那么如何从beandefinition中实例化bean对象呢\",{\"1\":{\"38\":1,\"49\":1,\"50\":1}}],[\"那么这些spring\",{\"1\":{\"38\":1}}],[\"那么\",{\"1\":{\"3\":1,\"13\":1}}],[\"需要有如下顶层思维\",{\"1\":{\"62\":1}}],[\"需要去掉\",{\"1\":{\"53\":2}}],[\"需要高一点层次整体上去理解它\",{\"1\":{\"39\":1}}],[\"需要进一步学习springmvc\",{\"1\":{\"38\":1}}],[\"需绑定自定义域名\",{\"1\":{\"11\":1}}],[\"基于spring框架和ioc\",{\"1\":{\"38\":1}}],[\"基础和overview\",{\"1\":{\"39\":2}}],[\"基础\",{\"0\":{\"24\":1,\"68\":1},\"1\":{\"24\":1}}],[\"向你展示spring\",{\"1\":{\"38\":1}}],[\"向上转型\",{\"1\":{\"27\":1,\"28\":1}}],[\"它是一棵空树或它的左右两个子树的高度差的绝对值不超过1\",{\"1\":{\"39\":1}}],[\"它是怎么诞生的\",{\"1\":{\"38\":1}}],[\"它的优点是\",{\"1\":{\"39\":1}}],[\"它的左\",{\"1\":{\"39\":1}}],[\"它的应用是文件系统及部分非关系型数据库索引\",{\"1\":{\"39\":1}}],[\"它或者是一棵空树\",{\"1\":{\"39\":1}}],[\"它通过把关键码值映射到表中一个位置来访问记录\",{\"1\":{\"39\":1}}],[\"它们的底层实现就是红黑树\",{\"1\":{\"39\":1}}],[\"它们都覆盖了父类的\",{\"1\":{\"28\":1}}],[\"从上面三级缓存的分析\",{\"1\":{\"55\":1}}],[\"从beandefinition中获得beanclassname\",{\"1\":{\"52\":1}}],[\"从beandefinitionmap通过beanname获得beandefinition\",{\"1\":{\"52\":1}}],[\"从spring框架的整体架构和组成对整体框架有个认知\",{\"1\":{\"38\":1}}],[\"从而影响\",{\"1\":{\"35\":1}}],[\"从而获得\",{\"1\":{\"27\":1}}],[\"从而正确显示样式和功能\",{\"1\":{\"13\":1}}],[\"从而生成位于国内的静态页面\",{\"1\":{\"9\":1}}],[\"相关文章\",{\"0\":{\"38\":1},\"1\":{\"39\":1}}],[\"6844903843596107790\",{\"1\":{\"65\":1}}],[\"6012105\",{\"1\":{\"36\":1}}],[\"6475334\",{\"1\":{\"36\":1}}],[\"抽象类与oop三大特征\",{\"1\":{\"36\":1}}],[\"70037927\",{\"1\":{\"36\":1}}],[\"顺序图\",{\"1\":{\"36\":1}}],[\"系列\",{\"1\":{\"36\":1}}],[\"系统会显示红色错误提示\",{\"1\":{\"3\":1}}],[\"系统优化和相关问题\",{\"1\":{\"2\":1}}],[\"系统问题\",{\"1\":{\"2\":1}}],[\"看懂\",{\"1\":{\"36\":1}}],[\"看板娘\",{\"0\":{\"6\":1}}],[\"模式与实践\",{\"1\":{\"36\":1}}],[\"模板帮助你新建并初始化仓库\",{\"1\":{\"11\":1}}],[\"敏捷软件开发\",{\"1\":{\"36\":1}}],[\"编程思想\",{\"1\":{\"36\":1}}],[\"编译时多态主要指方法的重载\",{\"1\":{\"28\":1}}],[\"局部变量\",{\"1\":{\"35\":1}}],[\"某中方法的\",{\"1\":{\"35\":1}}],[\"比如beandefinition中其它定义\",{\"1\":{\"52\":1}}],[\"比如地图两点间距离计算\",{\"1\":{\"39\":1}}],[\"比如实际应用当中\",{\"1\":{\"39\":1}}],[\"比如web\",{\"1\":{\"38\":1}}],[\"比如ioc和aop等\",{\"1\":{\"38\":1}}],[\"比如学生和学校就是一种关联关系\",{\"1\":{\"34\":1}}],[\"比如公司和部门\",{\"1\":{\"33\":1}}],[\"多例循环依赖\",{\"1\":{\"60\":1}}],[\"多实例bean是每次调用一次getbean都会执行一次构造方法并且给属性赋值\",{\"1\":{\"59\":1}}],[\"多路查找树\",{\"1\":{\"39\":1}}],[\"多对多这种关联关系来表示\",{\"1\":{\"34\":1}}],[\"多对\",{\"1\":{\"34\":1}}],[\"多态在新窗口打开\",{\"1\":{\"36\":1}}],[\"多态分为编译时多态和运行时多态\",{\"1\":{\"28\":1}}],[\"多态\",{\"0\":{\"28\":1},\"1\":{\"24\":1}}],[\"对该\",{\"1\":{\"62\":1}}],[\"对于\",{\"1\":{\"61\":1}}],[\"对于数据结构这种基础内容\",{\"1\":{\"39\":1}}],[\"对advisor排序\",{\"1\":{\"46\":1}}],[\"对\",{\"1\":{\"34\":1,\"62\":1}}],[\"对象\",{\"1\":{\"27\":1,\"28\":1}}],[\"对象的\",{\"1\":{\"26\":1}}],[\"与运行过程的状态无关\",{\"1\":{\"34\":1}}],[\"整体不存在了部分也不存在了\",{\"1\":{\"33\":1}}],[\"整体不存在了部分还是会存在\",{\"1\":{\"32\":1}}],[\"组合中整体和部分是强依赖的\",{\"1\":{\"33\":1}}],[\"组合关系\",{\"0\":{\"33\":1},\"1\":{\"24\":1}}],[\"表示是否目标类实现了接口\",{\"1\":{\"48\":1}}],[\"表示优先使用cglib代理\",{\"1\":{\"48\":1}}],[\"表示配置是自定义的\",{\"1\":{\"48\":1}}],[\"表示不同类对象之间有关联\",{\"1\":{\"34\":1}}],[\"表示整体由部分组成\",{\"1\":{\"32\":1}}],[\"表示服务器配置错误\",{\"1\":{\"14\":1}}],[\"绘制\",{\"1\":{\"29\":1}}],[\"乐器类\",{\"1\":{\"28\":1}}],[\"下面的代码中\",{\"1\":{\"28\":1}}],[\"下的\",{\"1\":{\"6\":1}}],[\"重点\",{\"0\":{\"54\":1,\"61\":1},\"1\":{\"45\":2,\"49\":2}}],[\"重写\",{\"1\":{\"28\":1}}],[\"重新进行部署\",{\"1\":{\"14\":1}}],[\"覆盖\",{\"1\":{\"28\":1}}],[\"运行时多态有三个条件\",{\"1\":{\"28\":1}}],[\"运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定\",{\"1\":{\"28\":1}}],[\"父类引用指向子类对象称为\",{\"1\":{\"27\":1}}],[\"引入\",{\"0\":{\"44\":1,\"50\":1},\"1\":{\"43\":1,\"49\":1}}],[\"引用调用\",{\"1\":{\"28\":1}}],[\"引用\",{\"1\":{\"27\":1}}],[\"引起的\",{\"1\":{\"15\":1}}],[\"也没有\",{\"1\":{\"55\":1}}],[\"也就不需要代理了\",{\"1\":{\"45\":1}}],[\"也就是beanb需要在beana的构造函数中完成初始化\",{\"1\":{\"57\":1}}],[\"也就是没有初始化完成\",{\"1\":{\"55\":1}}],[\"也就是将三级缓存提高到二级缓存中\",{\"1\":{\"55\":1}}],[\"也就是说单例对象此时已经被建立出来的\",{\"1\":{\"55\":1}}],[\"也就是说\",{\"1\":{\"39\":1}}],[\"也就是说可以使用\",{\"1\":{\"27\":1}}],[\"也就是构建avl树比较麻烦\",{\"1\":{\"39\":1}}],[\"也叫哈希表\",{\"1\":{\"39\":1}}],[\"也可以在不影响客户端代码的情况下进行\",{\"1\":{\"26\":1}}],[\"子类对象必须能够替换掉所有父类对象\",{\"1\":{\"27\":1}}],[\"非叶子结点作为叶子结点的索引\",{\"1\":{\"39\":1}}],[\"非\",{\"1\":{\"27\":1}}],[\"关键路径在项目管理计算工期等方面有广泛等应用\",{\"1\":{\"39\":1}}],[\"关键路径\",{\"1\":{\"39\":1}}],[\"关键路径等\",{\"1\":{\"39\":1}}],[\"关键字\",{\"1\":{\"30\":1,\"31\":1}}],[\"关联\",{\"1\":{\"62\":5}}],[\"关联数组具有较高的查询效率\",{\"1\":{\"39\":1}}],[\"关联关系\",{\"0\":{\"34\":1},\"1\":{\"24\":1}}],[\"关系\",{\"1\":{\"27\":2}}],[\"<bean>\",{\"1\":{\"62\":2}}],[\"<t>\",{\"1\":{\"51\":2,\"53\":3}}],[\"<p>uses\",{\"1\":{\"47\":1}}],[\"<p>can\",{\"1\":{\"47\":1}}],[\"<|\",{\"1\":{\"30\":2,\"31\":2}}],[\"<=\",{\"1\":{\"26\":2}}],[\"<script\",{\"1\":{\"6\":2}}],[\"方法将\",{\"1\":{\"62\":1}}],[\"方法传入classloader的引用\",{\"1\":{\"62\":1}}],[\"方法传入当前工厂实例的引用\",{\"1\":{\"62\":1}}],[\"方法传入当前\",{\"1\":{\"62\":4}}],[\"方法获取\",{\"1\":{\"52\":2}}],[\"方法获取一个\",{\"1\":{\"26\":1}}],[\"方法时\",{\"1\":{\"28\":1}}],[\"方法中使用父类\",{\"1\":{\"28\":1}}],[\"方法\",{\"1\":{\"28\":2,\"44\":1,\"62\":1}}],[\"方法使用\",{\"1\":{\"26\":1}}],[\"而对于\",{\"1\":{\"61\":1}}],[\"而且将本身提早曝光到singletonfactories中\",{\"1\":{\"55\":1}}],[\"而且对象正在建立中\",{\"1\":{\"55\":1}}],[\"而且无序数组的查找最坏情况需要遍历整个数组\",{\"1\":{\"39\":1}}],[\"而直接进行访问的数据结构\",{\"1\":{\"39\":1}}],[\"而spring中循环依赖的解决正是通过缓存来实现的\",{\"1\":{\"58\":1}}],[\"而spring还需要考虑各种设计上的问题\",{\"1\":{\"52\":1}}],[\"而spring\",{\"1\":{\"38\":1}}],[\"而不是\",{\"1\":{\"28\":1}}],[\"而无法获取\",{\"1\":{\"26\":1}}],[\"而是将文档同步到国内服务器\",{\"1\":{\"9\":1}}],[\"而是将被自动复制到静态网站下\",{\"1\":{\"7\":1}}],[\"属性指定了\",{\"1\":{\"62\":1}}],[\"属性指定了初始化方法\",{\"1\":{\"62\":1}}],[\"属性值从beandefinition的getpropertyvalues\",{\"1\":{\"52\":1}}],[\"属性使用的数据类型时\",{\"1\":{\"26\":1}}],[\"属性使用\",{\"1\":{\"26\":1}}],[\"属性可以供\",{\"1\":{\"26\":1}}],[\"属性\",{\"1\":{\"26\":2}}],[\"属性和\",{\"1\":{\"26\":1}}],[\"外界只能通过\",{\"1\":{\"26\":1}}],[\"类似的依赖是如何解决\",{\"1\":{\"60\":1}}],[\"类发生变化\",{\"1\":{\"35\":1}}],[\"类发送消息\",{\"1\":{\"35\":1}}],[\"类向\",{\"1\":{\"35\":1}}],[\"类方法当中的一个参数\",{\"1\":{\"35\":1}}],[\"类中的\",{\"1\":{\"35\":1}}],[\"类是\",{\"1\":{\"35\":2}}],[\"类是依赖关系主要有三种形式\",{\"1\":{\"35\":1}}],[\"类和\",{\"1\":{\"35\":1}}],[\"类的方法\",{\"1\":{\"28\":1}}],[\"类封装\",{\"1\":{\"26\":1}}],[\"类图和时序图在新窗口打开\",{\"1\":{\"36\":1}}],[\"类图\",{\"0\":{\"29\":1},\"1\":{\"24\":1}}],[\"即首先尝试从bean工厂中获取bean\",{\"1\":{\"62\":1}}],[\"即需要创建代理\",{\"1\":{\"47\":1}}],[\"即spring\",{\"1\":{\"44\":1}}],[\"即使整个系统不可用\",{\"1\":{\"26\":1}}],[\"即可\",{\"1\":{\"3\":1,\"11\":1}}],[\"降低了构建大型系统的风险\",{\"1\":{\"26\":1}}],[\"减轻维护的负担\",{\"1\":{\"26\":1}}],[\"减少耦合\",{\"1\":{\"26\":1}}],[\"理解和修改\",{\"1\":{\"26\":1}}],[\"优化\",{\"1\":{\"26\":1}}],[\"优点\",{\"1\":{\"26\":1}}],[\"测试的主方法\",{\"1\":{\"63\":1}}],[\"测试\",{\"1\":{\"26\":1}}],[\"尽可能地隐藏内部的细节\",{\"1\":{\"26\":1}}],[\"数组和链表都是线性存储结构的基础\",{\"1\":{\"39\":1}}],[\"数组和矩阵\",{\"1\":{\"39\":2}}],[\"数组尺寸不能改变\",{\"1\":{\"39\":1}}],[\"数组是多维的\",{\"1\":{\"39\":1}}],[\"数组是一种连续存储线性结构\",{\"1\":{\"39\":1}}],[\"数组不能无限长\",{\"1\":{\"39\":1}}],[\"数组不会被优先考虑\",{\"1\":{\"39\":1}}],[\"数组的下标寻址十分迅速\",{\"1\":{\"39\":1}}],[\"数据结构知识体系\",{\"0\":{\"72\":1}}],[\"数据结构之\",{\"1\":{\"39\":3}}],[\"数据结构是基础中的基础\",{\"1\":{\"39\":1}}],[\"数据结构\",{\"1\":{\"39\":2}}],[\"数据库系统\",{\"1\":{\"39\":1}}],[\"数据类型进行存储\",{\"1\":{\"26\":1}}],[\"数据被保护在抽象数据类型的内部\",{\"1\":{\"26\":1}}],[\"数字越小越靠前\",{\"1\":{\"5\":1}}],[\"使用了三级缓存\",{\"1\":{\"54\":1}}],[\"使用\",{\"1\":{\"26\":1,\"60\":3}}],[\"使用指南\",{\"2\":{\"19\":1,\"20\":1,\"23\":1}}],[\"使其构成一个不可分割的独立实体\",{\"1\":{\"26\":1}}],[\"参数typecheckonly\",{\"1\":{\"53\":1}}],[\"参数表示侧边栏的顺序\",{\"1\":{\"5\":1}}],[\"参考文章\",{\"0\":{\"42\":1,\"65\":1},\"1\":{\"39\":1,\"49\":1}}],[\"参考资料\",{\"0\":{\"36\":1},\"1\":{\"24\":1}}],[\"聚合关系\",{\"0\":{\"32\":1},\"1\":{\"24\":1}}],[\"聚合所有博客文章\",{\"1\":{\"2\":1}}],[\"泛化关系\",{\"0\":{\"30\":1},\"1\":{\"24\":1}}],[\"继承应该遵循里氏替换原则\",{\"1\":{\"27\":1}}],[\"继承实现了\",{\"1\":{\"27\":1}}],[\"继承\",{\"0\":{\"27\":1},\"1\":{\"24\":1,\"28\":1,\"36\":1}}],[\"封装使得用户注意不到这种实现细节\",{\"1\":{\"26\":1}}],[\"封装\",{\"0\":{\"26\":1},\"1\":{\"24\":1,\"36\":1}}],[\"面向对象编程\",{\"1\":{\"36\":1}}],[\"面向对象编程三大特性\",{\"1\":{\"36\":1}}],[\"面向对象设计的\",{\"1\":{\"36\":1}}],[\"面向对象基础和相关类图\",{\"1\":{\"24\":1}}],[\"面向对象\",{\"0\":{\"24\":1},\"1\":{\"24\":1}}],[\"语言\",{\"1\":{\"18\":1,\"21\":1}}],[\"高效知识管理和进阶应用技巧\",{\"1\":{\"17\":1}}],[\"若是仍是获取不到且容许singletonfactories经过getobject\",{\"1\":{\"55\":1}}],[\"若是仍是获取不到而且容许从singletonfactories经过getobject获取\",{\"1\":{\"55\":1}}],[\"若是获取到了则从三级缓存移动到了二级缓存\",{\"1\":{\"55\":1}}],[\"若是获取到了则将singletonobject放入到earlysingletonobjects\",{\"1\":{\"55\":1}}],[\"若是获取不到\",{\"1\":{\"55\":1}}],[\"若是获取不到而且对象在建立中\",{\"1\":{\"55\":1}}],[\"若它的右子树不空\",{\"1\":{\"39\":1}}],[\"若它的左子树不空\",{\"1\":{\"39\":1}}],[\"若需停止本地服务器\",{\"1\":{\"17\":1}}],[\"若成功则会提示访问链接\",{\"1\":{\"17\":1}}],[\"若该名称已被其他项目使用\",{\"1\":{\"3\":1}}],[\"安装依赖\",{\"1\":{\"17\":1}}],[\"环境\",{\"1\":{\"17\":1}}],[\"环境依赖未正确配置\",{\"1\":{\"16\":1}}],[\"此处非常重要\",{\"1\":{\"62\":1}}],[\"此处就是解决循环依赖的关键\",{\"1\":{\"55\":1}}],[\"此报错出现的几率极低\",{\"1\":{\"16\":1}}],[\"此时返回a中\",{\"1\":{\"55\":1}}],[\"此时就尝试去get\",{\"1\":{\"55\":1}}],[\"此时进行初始化的第二步\",{\"1\":{\"55\":1}}],[\"此时\",{\"1\":{\"3\":2,\"11\":1,\"62\":1}}],[\"只负责创建\",{\"1\":{\"61\":1}}],[\"只帮我们管理单例模式\",{\"1\":{\"61\":1}}],[\"只有非接口的是通过cglib代理实现的\",{\"1\":{\"48\":1}}],[\"只有经过消化\",{\"1\":{\"1\":1}}],[\"只保留一些对外接口使之与外部发生联系\",{\"1\":{\"26\":1}}],[\"只需在\",{\"1\":{\"15\":1}}],[\"静态构建过程中不会出现\",{\"1\":{\"15\":1}}],[\"时\",{\"1\":{\"61\":1}}],[\"时序图\",{\"1\":{\"36\":1}}],[\"时使用非\",{\"1\":{\"15\":1}}],[\"时间轴等方式进行组合\",{\"1\":{\"2\":1}}],[\"检查\",{\"1\":{\"14\":1}}],[\"来配置的\",{\"1\":{\"48\":1}}],[\"来引用\",{\"1\":{\"28\":1}}],[\"来使用\",{\"1\":{\"27\":1}}],[\"来覆盖本地设置\",{\"1\":{\"16\":1}}],[\"来测试\",{\"1\":{\"14\":1}}],[\"来构建读书笔记\",{\"1\":{\"7\":1}}],[\"密码错误或账号不存在\",{\"1\":{\"14\":1}}],[\"指定加载先后关系\",{\"1\":{\"60\":1}}],[\"指同步服务器出现超时报错\",{\"1\":{\"14\":1}}],[\"指\",{\"1\":{\"14\":1}}],[\"5c84f7b6c354\",{\"1\":{\"42\":1}}],[\"50\",{\"1\":{\"26\":1}}],[\"530\",{\"1\":{\"14\":1}}],[\"547\",{\"1\":{\"63\":1}}],[\"54\",{\"1\":{\"5\":1}}],[\"yaml\",{\"1\":{\"16\":1}}],[\"yml\",{\"1\":{\"14\":1}}],[\"yyy\",{\"1\":{\"6\":4}}],[\"embeddedvalueresolveraware\",{\"1\":{\"62\":1}}],[\"empty\",{\"1\":{\"46\":1,\"47\":1}}],[\"earlysingletonobjects\",{\"1\":{\"55\":4}}],[\"early\",{\"1\":{\"55\":1}}],[\"earlyproxyreferences\",{\"1\":{\"45\":1}}],[\"eagerly\",{\"1\":{\"53\":2}}],[\"either\",{\"1\":{\"48\":1}}],[\"effect\",{\"1\":{\"47\":1}}],[\"entity\",{\"1\":{\"63\":11}}],[\"environment\",{\"1\":{\"62\":1}}],[\"environmentaware\",{\"1\":{\"62\":1}}],[\"end\",{\"1\":{\"53\":1}}],[\"enduml\",{\"1\":{\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1}}],[\"enforced\",{\"1\":{\"47\":1}}],[\"evaluateproxyinterfaces\",{\"1\":{\"47\":1}}],[\"evaluate\",{\"1\":{\"46\":1}}],[\"equals\",{\"1\":{\"45\":1}}],[\"eligibleadvisors\",{\"1\":{\"46\":11}}],[\"eligible\",{\"1\":{\"45\":1,\"46\":1}}],[\"else\",{\"1\":{\"26\":1,\"47\":2,\"48\":1,\"53\":6}}],[\"e\",{\"1\":{\"45\":1}}],[\"err\",{\"0\":{\"16\":1},\"1\":{\"16\":1}}],[\"error\",{\"1\":{\"14\":2,\"16\":1}}],[\"execute\",{\"1\":{\"63\":32}}],[\"extern\",{\"1\":{\"63\":1}}],[\"extendadvisors\",{\"1\":{\"46\":2}}],[\"extends\",{\"1\":{\"28\":2,\"30\":1}}],[\"exception\",{\"1\":{\"53\":1,\"63\":2}}],[\"ex\",{\"1\":{\"53\":10}}],[\"explicitly\",{\"1\":{\"53\":1}}],[\"explicit\",{\"1\":{\"47\":1,\"53\":1}}],[\"exposetargetclass\",{\"1\":{\"47\":1}}],[\"export\",{\"1\":{\"13\":1}}],[\"exit\",{\"1\":{\"3\":1}}],[\"应保留默认值\",{\"1\":{\"13\":1}}],[\"应用\",{\"1\":{\"1\":1,\"38\":1}}],[\"如下是获取单例中\",{\"1\":{\"55\":1}}],[\"如上只是我们初步的思路\",{\"1\":{\"52\":1}}],[\"如mysql\",{\"1\":{\"39\":1}}],[\"如xml\",{\"1\":{\"38\":1}}],[\"如\",{\"1\":{\"13\":1}}],[\"如果在\",{\"1\":{\"62\":2}}],[\"如果在配置文件中通过\",{\"1\":{\"62\":2}}],[\"如果在此步骤中未找到\",{\"1\":{\"3\":1}}],[\"如果\",{\"1\":{\"53\":1,\"62\":13}}],[\"如果获取不到再通过上述步骤获取\",{\"1\":{\"52\":1}}],[\"如果获取不到返回do\",{\"1\":{\"46\":1}}],[\"如果是无参构造函数的实例还可以放在一个缓存中\",{\"1\":{\"52\":1}}],[\"如果是aop基础类\",{\"1\":{\"45\":1}}],[\"如果有advisor\",{\"1\":{\"47\":1}}],[\"如果需要\",{\"1\":{\"46\":1}}],[\"如果没有获取到\",{\"1\":{\"45\":1}}],[\"如果bean\",{\"1\":{\"53\":1}}],[\"如果bean实例还在创建中\",{\"1\":{\"53\":2}}],[\"如果bean是工厂类\",{\"1\":{\"53\":2}}],[\"如果bean是切面类\",{\"1\":{\"45\":1}}],[\"如果bean是通过targetsource接口获取\",{\"1\":{\"45\":1}}],[\"如果bean能够获取到advisor才需要创建代理\",{\"1\":{\"45\":1}}],[\"如果bean被子类标识为代理\",{\"1\":{\"45\":1}}],[\"如果不是提前暴露的代理\",{\"1\":{\"45\":1}}],[\"如果不需要看板娘\",{\"1\":{\"6\":1}}],[\"如果元素数量非常多的话\",{\"1\":{\"39\":1}}],[\"如果遇到\",{\"1\":{\"16\":1}}],[\"如果出现\",{\"1\":{\"16\":1}}],[\"如果出现该错误\",{\"1\":{\"14\":1}}],[\"如果错误连续出现\",{\"1\":{\"14\":1}}],[\"如果图片名称为\",{\"1\":{\"8\":1}}],[\"如果网站部署在子页面\",{\"1\":{\"6\":1}}],[\"如果你不需要将网页部署同步到服务器\",{\"1\":{\"14\":1}}],[\"如果你未登录\",{\"1\":{\"11\":1}}],[\"如果你的网站是部署在根路径\",{\"1\":{\"13\":1}}],[\"如果你的网站仅显示文本而不正常加载样式和脚本\",{\"1\":{\"13\":1}}],[\"如果你的项目已经搭建好\",{\"1\":{\"10\":1}}],[\"如果你的仓库链接是\",{\"1\":{\"3\":1}}],[\"如果你没有部署\",{\"1\":{\"7\":1}}],[\"如果你没用\",{\"1\":{\"5\":1}}],[\"如果你想深入了解\",{\"1\":{\"17\":1}}],[\"如果你想在服务器上自建\",{\"1\":{\"6\":1}}],[\"如果你想要修改看板娘模型\",{\"1\":{\"6\":1}}],[\"如果页面样式显示不正常\",{\"1\":{\"3\":1}}],[\"如果设置无误\",{\"1\":{\"3\":1}}],[\"刷新网站应能正常显示\",{\"1\":{\"13\":1}}],[\"等\",{\"1\":{\"39\":1}}],[\"等属性\",{\"1\":{\"26\":1}}],[\"等待\",{\"1\":{\"13\":1}}],[\"等多款知识管理工具来存储我的心得与笔记\",{\"1\":{\"1\":1}}],[\"提供的方法定制\",{\"1\":{\"62\":1}}],[\"提升工期就是所见缩减所有关键路径上的工期\",{\"1\":{\"39\":1}}],[\"提示\",{\"1\":{\"37\":1,\"39\":1}}],[\"提示你注册或登录\",{\"1\":{\"11\":1}}],[\"提高软件的可重用性\",{\"1\":{\"26\":1}}],[\"提交并推送更改\",{\"1\":{\"13\":1}}],[\"其次\",{\"1\":{\"38\":1}}],[\"其他配置\",{\"1\":{\"13\":1}}],[\"其中包含根据bean的名字\",{\"1\":{\"51\":1}}],[\"其中\",{\"1\":{\"5\":1}}],[\"打开\",{\"1\":{\"13\":1}}],[\"找到这些advisor中能够应用于beanclass的advisor\",{\"1\":{\"46\":2}}],[\"找到parse\",{\"1\":{\"44\":1}}],[\"找到两个城市之间的最短路径等等\",{\"1\":{\"39\":1}}],[\"找到配置文件\",{\"1\":{\"13\":1}}],[\"找到页面底部的\",{\"1\":{\"3\":1}}],[\"常见问题\",{\"0\":{\"12\":1}}],[\"常用代码的学习和使用笔记\",{\"1\":{\"2\":1}}],[\"常用应用\",{\"1\":{\"2\":1}}],[\"🤔\",{\"0\":{\"12\":1}}],[\"🧱\",{\"0\":{\"2\":1}}],[\"跳转到应用的控制台\",{\"1\":{\"11\":1}}],[\"满屏的烟花会庆祝你部署成功\",{\"1\":{\"11\":1}}],[\"会调用\",{\"1\":{\"62\":1}}],[\"会在\",{\"1\":{\"61\":1}}],[\"会执行实际引用对象所在类的\",{\"1\":{\"28\":1}}],[\"会基于\",{\"1\":{\"11\":1}}],[\"会自动生成可访问的网页\",{\"1\":{\"9\":1}}],[\"会自动创建一个名为\",{\"1\":{\"3\":1}}],[\"接口\",{\"1\":{\"62\":8}}],[\"接着\",{\"1\":{\"11\":1}}],[\"接下来\",{\"1\":{\"3\":1}}],[\"创建bean实例\",{\"1\":{\"53\":3}}],[\"创建代理的方法如下\",{\"1\":{\"47\":1}}],[\"创建代理的方法是postprocessafterinitialization\",{\"1\":{\"45\":1}}],[\"创建代理的入口方法\",{\"0\":{\"47\":1},\"1\":{\"43\":1}}],[\"创建代理\",{\"1\":{\"44\":1,\"45\":1}}],[\"创建\",{\"1\":{\"11\":1}}],[\"默认是false\",{\"1\":{\"48\":2}}],[\"默认为\",{\"1\":{\"17\":1}}],[\"默认\",{\"1\":{\"11\":1}}],[\"默认采用\",{\"1\":{\"5\":1}}],[\"项目下载到本地后\",{\"1\":{\"17\":1}}],[\"项目\",{\"1\":{\"11\":1}}],[\"项目名称\",{\"1\":{\"11\":1}}],[\"项目页面\",{\"1\":{\"3\":1}}],[\"账户进行快捷登录\",{\"1\":{\"11\":1}}],[\"仓库名为你之前输入的项目名\",{\"1\":{\"11\":1}}],[\"仓库名\",{\"1\":{\"11\":1}}],[\"uml\",{\"1\":{\"36\":2}}],[\"url=https\",{\"1\":{\"11\":1}}],[\"user\",{\"1\":{\"63\":46}}],[\"username\",{\"1\":{\"10\":1}}],[\"use\",{\"1\":{\"3\":1,\"46\":1,\"47\":1}}],[\"污染影响\",{\"1\":{\"11\":1}}],[\"域名会发生\",{\"1\":{\"15\":1}}],[\"域名已受\",{\"1\":{\"11\":1}}],[\"域名需要备案\",{\"1\":{\"9\":1}}],[\"更多语法及使用请参考\",{\"1\":{\"29\":1}}],[\"更快\",{\"1\":{\"11\":1}}],[\"更重要的是\",{\"1\":{\"1\":1}}],[\"就从三级缓存singletonfactory\",{\"1\":{\"55\":1}}],[\"就再从二级缓存earlysingletonobjects中获取\",{\"1\":{\"55\":1}}],[\"就是利用它实现的\",{\"1\":{\"62\":1}}],[\"就是一种\",{\"1\":{\"27\":1}}],[\"就是你的\",{\"1\":{\"3\":1}}],[\"就会将修改推送到服务器的\",{\"1\":{\"10\":1}}],[\"每次客户端请求\",{\"1\":{\"61\":1}}],[\"每次新增文章都会在上一篇的基础上递减\",{\"1\":{\"5\":1}}],[\"每个节点只有一个后续节点\",{\"1\":{\"39\":1}}],[\"每个节点只有一个前驱节点\",{\"1\":{\"39\":1}}],[\"每当文件发生变化时\",{\"1\":{\"10\":1}}],[\"之后\",{\"1\":{\"10\":1}}],[\"factories\",{\"1\":{\"55\":1}}],[\"factory\",{\"1\":{\"47\":1,\"63\":7}}],[\"facility\",{\"1\":{\"47\":1}}],[\"false\",{\"1\":{\"45\":3,\"53\":4}}],[\"failed\",{\"0\":{\"15\":1},\"1\":{\"3\":1,\"8\":1,\"14\":1,\"15\":1}}],[\"flag\",{\"1\":{\"47\":1}}],[\"flowing\",{\"1\":{\"42\":1}}],[\"fly\",{\"1\":{\"31\":2}}],[\"from\",{\"1\":{\"53\":1,\"63\":1}}],[\"frolyd\",{\"1\":{\"39\":2}}],[\"freezeproxy\",{\"1\":{\"47\":1}}],[\"framework组件的典型应用场景和基于这个场景设计出的简单案例\",{\"1\":{\"38\":1}}],[\"framework组件是如何配合工作的呢\",{\"1\":{\"38\":1}}],[\"framework的组件\",{\"1\":{\"38\":1}}],[\"framework的整体认知\",{\"1\":{\"38\":1}}],[\"f\",{\"1\":{\"39\":3}}],[\"for\",{\"1\":{\"28\":1,\"45\":2,\"46\":4,\"47\":8,\"48\":1,\"53\":5,\"63\":10}}],[\"found\",{\"1\":{\"16\":1,\"53\":1,\"66\":1}}],[\"final\",{\"1\":{\"55\":3}}],[\"finally\",{\"1\":{\"53\":3}}],[\"findadvisorbeans\",{\"1\":{\"46\":1}}],[\"findadvisorsthatcanapply\",{\"1\":{\"46\":2}}],[\"findcandidateadvisors\",{\"1\":{\"46\":3}}],[\"findeligibleadvisors方法如下\",{\"1\":{\"46\":1}}],[\"findeligibleadvisors\",{\"1\":{\"46\":2}}],[\"find\",{\"1\":{\"16\":1,\"46\":3}}],[\"first\",{\"1\":{\"39\":2}}],[\"filezilla\",{\"1\":{\"14\":1}}],[\"files\",{\"1\":{\"14\":1}}],[\"ftperror\",{\"1\":{\"14\":1}}],[\"ftp\",{\"1\":{\"10\":5,\"14\":2}}],[\"同样不适合进行查找\",{\"1\":{\"39\":1}}],[\"同时我们也总结了spring\",{\"1\":{\"44\":1}}],[\"同时它的设计依赖散列函数的设计\",{\"1\":{\"39\":1}}],[\"同时以此发散了一些aop相关知识点\",{\"1\":{\"38\":1}}],[\"同时以此发散了一些ioc相关知识点\",{\"1\":{\"38\":1}}],[\"同时对ioc和aop进行案例使用分析\",{\"1\":{\"38\":1}}],[\"同时不会影响那些寻求干货文章的用户体验\",{\"1\":{\"5\":1}}],[\"同步服务器报错\",{\"0\":{\"14\":1}}],[\"同步到\",{\"1\":{\"10\":1}}],[\"同步到服务器时发生了错误\",{\"1\":{\"10\":1}}],[\"同步到服务器\",{\"0\":{\"10\":1}}],[\"国外服务可能会出现断网\",{\"1\":{\"9\":1}}],[\"vary\",{\"1\":{\"47\":1}}],[\"valueof\",{\"1\":{\"53\":1}}],[\"value\",{\"1\":{\"39\":1}}],[\"visualizations在新窗口打开\",{\"1\":{\"40\":1}}],[\"ve\",{\"1\":{\"47\":1}}],[\"vehicle\",{\"1\":{\"35\":3}}],[\"vehical\",{\"1\":{\"30\":3}}],[\"very\",{\"1\":{\"26\":1}}],[\"vercel\",{\"0\":{\"11\":1},\"1\":{\"9\":1,\"11\":10}}],[\"void\",{\"1\":{\"26\":1,\"28\":4,\"63\":11}}],[\"vuepress2\",{\"1\":{\"5\":1}}],[\"vuepress\",{\"1\":{\"1\":2,\"5\":6,\"6\":4,\"7\":1,\"8\":2,\"13\":1,\"15\":1}}],[\"近期也发生过下架风波\",{\"1\":{\"9\":1}}],[\"免费版无法自定义域名\",{\"1\":{\"9\":1}}],[\"有两处比较重要的匿名内部类实现了该接口\",{\"1\":{\"55\":1}}],[\"有两个子类\",{\"1\":{\"28\":1}}],[\"有依赖关系\",{\"1\":{\"39\":1}}],[\"有向无环图\",{\"1\":{\"39\":1}}],[\"有哪些主要的组件和核心功能呢\",{\"1\":{\"38\":1}}],[\"有效地调节性能\",{\"1\":{\"26\":1}}],[\"有很多限制\",{\"1\":{\"9\":1}}],[\"有评论插件的相关配置\",{\"1\":{\"5\":1}}],[\"建议增加国内的访问节点\",{\"1\":{\"9\":1}}],[\"但一般情况下\",{\"1\":{\"61\":1}}],[\"但不仅限于字符串\",{\"1\":{\"39\":1}}],[\"但计算机的内存是有限的\",{\"1\":{\"39\":1}}],[\"但可以通过对象对外提供的接口来访问该对象\",{\"1\":{\"26\":1}}],[\"但\",{\"1\":{\"11\":1}}],[\"但出现了红色的叉叉提示\",{\"1\":{\"10\":1}}],[\"但是的在调用构造方法之前还未将其放入三级缓存之中\",{\"1\":{\"57\":1}}],[\"但是avl树的旋转过程非常麻烦\",{\"1\":{\"39\":1}}],[\"但是一个学生只属于一个学校\",{\"1\":{\"34\":1}}],[\"但是公司和员工就属于聚合关系了\",{\"1\":{\"33\":1}}],[\"但是整体和部分不是强依赖的\",{\"1\":{\"32\":1}}],[\"但是这些独立的模块却有可能是可用的\",{\"1\":{\"26\":1}}],[\"但是\",{\"1\":{\"9\":1,\"26\":1}}],[\"但由于国内访问\",{\"1\":{\"9\":1}}],[\"但网页链接路径会是\",{\"1\":{\"5\":1}}],[\"后处理器\",{\"1\":{\"62\":1}}],[\"后来人们提出了二分查找\",{\"1\":{\"39\":1}}],[\"后\",{\"1\":{\"9\":1}}],[\"后台会自动抓取路径下的\",{\"1\":{\"5\":1}}],[\"🖥️\",{\"0\":{\"9\":1}}],[\"🔣\",{\"0\":{\"4\":1}}],[\"本章节中有部分图源于这位作者\",{\"1\":{\"40\":1}}],[\"本质上是一个concurrenthashmap<string\",{\"1\":{\"38\":1,\"49\":1,\"50\":1,\"52\":1}}],[\"本节将在此基础上进一步解读aop的含义以及aop的使用方式\",{\"1\":{\"38\":1}}],[\"本节将在此基础上进一步解读ioc的含义以及ioc的使用方式\",{\"1\":{\"38\":1}}],[\"本文接着介绍postprocessafterinitialization的方法\",{\"1\":{\"44\":1}}],[\"本文是第二篇\",{\"1\":{\"38\":1}}],[\"本文是第一篇\",{\"1\":{\"38\":1}}],[\"本文在此基础上继续介绍\",{\"1\":{\"38\":1,\"43\":1}}],[\"本文将帮助你站在设计者的角度去看ioc最顶层的结构设计\",{\"1\":{\"38\":1}}],[\"本文主要研究如何从ioc容器已有的beandefinition信息\",{\"1\":{\"50\":1}}],[\"本文主要是springaop\",{\"1\":{\"38\":1}}],[\"本文主要介绍\",{\"1\":{\"39\":1}}],[\"本文主要介绍cglib动态代理的案例和springaop实现的原理\",{\"1\":{\"38\":1}}],[\"本文主要介绍spring\",{\"1\":{\"38\":1}}],[\"本文主要介绍springmvc的请求流程和基础案例的编写和运行\",{\"1\":{\"38\":1}}],[\"本文主要介绍java\",{\"1\":{\"24\":1}}],[\"本文主要承接上文\",{\"1\":{\"38\":1}}],[\"本文通过这几个问题帮助你构筑spring和spring\",{\"1\":{\"38\":1}}],[\"本系列主要介绍spring框架整体架构\",{\"1\":{\"37\":1}}],[\"本地服务运行后\",{\"1\":{\"17\":1}}],[\"本地运行\",{\"0\":{\"17\":1}}],[\"本地图片必须保存在\",{\"1\":{\"8\":1}}],[\"本地图片引用\",{\"0\":{\"8\":1}}],[\"本方法也适用于将附件部署到网站上\",{\"1\":{\"8\":1}}],[\"mybeanpostprocessor\",{\"1\":{\"63\":3}}],[\"mybeanfactorypostprocessor\",{\"1\":{\"63\":2}}],[\"myinstantiationawarebeanpostprocessor\",{\"1\":{\"63\":4}}],[\"message\",{\"1\":{\"53\":1}}],[\"method指定的方法\",{\"1\":{\"62\":1}}],[\"method和destroy\",{\"1\":{\"62\":1}}],[\"method\",{\"1\":{\"53\":1,\"62\":2}}],[\"metadata\",{\"1\":{\"45\":1}}],[\"might\",{\"1\":{\"53\":1}}],[\"missing\",{\"1\":{\"53\":1}}],[\"mbd\",{\"1\":{\"53\":14,\"55\":1}}],[\"must\",{\"1\":{\"47\":1}}],[\"music\",{\"1\":{\"28\":1}}],[\"mvc的规范推出的web开发框架\",{\"1\":{\"38\":1}}],[\"mvc是spring在spring\",{\"1\":{\"38\":1}}],[\"move\",{\"1\":{\"35\":3}}],[\"movebehavior\",{\"1\":{\"31\":3,\"35\":4}}],[\"mouse\",{\"1\":{\"32\":2}}],[\"more\",{\"1\":{\"26\":1}}],[\"module\",{\"0\":{\"16\":1},\"1\":{\"16\":2}}],[\"map<string\",{\"1\":{\"55\":3}}],[\"markbeanascreated\",{\"1\":{\"53\":1}}],[\"markdown\",{\"1\":{\"8\":1,\"18\":1,\"21\":1}}],[\"may\",{\"1\":{\"46\":1,\"47\":1}}],[\"manually\",{\"1\":{\"53\":1}}],[\"man\",{\"1\":{\"26\":1}}],[\"main\",{\"1\":{\"14\":1,\"28\":2,\"63\":20}}],[\"md\",{\"1\":{\"5\":4}}],[\"则将该\",{\"1\":{\"62\":2}}],[\"则调用该初始化方法\",{\"1\":{\"62\":1}}],[\"则调用postprocessafterinstantiation方法和postprocessproperties\",{\"1\":{\"62\":1}}],[\"则调用postprocessbeforeinstantiation方法\",{\"1\":{\"62\":1}}],[\"则调用postprocessbeanfactory方法\",{\"1\":{\"62\":1}}],[\"则\",{\"1\":{\"62\":11}}],[\"则经过singletonfactory\",{\"1\":{\"55\":1}}],[\"则尝试从earlysingletonobjects\",{\"1\":{\"55\":1}}],[\"则直接抛出异常\",{\"1\":{\"53\":2}}],[\"则说明需要增强\",{\"1\":{\"47\":1}}],[\"则使用配置的拦截器创建一个代理\",{\"1\":{\"45\":1}}],[\"则右子树上所有结点的值均大于它的根结点的值\",{\"1\":{\"39\":1}}],[\"则左子树上所有结点的值均小于它的根结点的值\",{\"1\":{\"39\":1}}],[\"则可以使用以下链接来引用该图片\",{\"1\":{\"8\":1}}],[\"则需将子页面路径\",{\"1\":{\"6\":1}}],[\"错误仅在本地运行\",{\"1\":{\"15\":1}}],[\"错误\",{\"1\":{\"8\":1}}],[\"或则在a的populatebean过程当中依赖了b对象\",{\"1\":{\"55\":1}}],[\"或者有执行\",{\"1\":{\"62\":2}}],[\"或者是具有下列性质的二叉树\",{\"1\":{\"39\":1}}],[\"或者删除主目录下的\",{\"1\":{\"16\":1}}],[\"或将\",{\"1\":{\"11\":1}}],[\"或\",{\"1\":{\"9\":1,\"39\":1}}],[\"或使用\",{\"1\":{\"8\":1}}],[\"或不需统计阅读量和评论功能\",{\"1\":{\"7\":1}}],[\"或尝试修改仓库中的任意文件以手动启动\",{\"1\":{\"3\":1}}],[\"不再管理该\",{\"1\":{\"62\":1}}],[\"不需要创建代理\",{\"1\":{\"46\":1}}],[\"不要盯着代码\",{\"1\":{\"39\":1}}],[\"不要忘记点击\",{\"1\":{\"3\":1}}],[\"不能使用相对链接\",{\"1\":{\"7\":1}}],[\"完成\",{\"1\":{\"7\":1}}],[\"完成设置后\",{\"1\":{\"3\":1}}],[\"该路径下的文件不会被转换为\",{\"1\":{\"7\":1}}],[\"因而尝试get\",{\"1\":{\"55\":1}}],[\"因为spring不会缓存\",{\"1\":{\"58\":1}}],[\"因为b拿到了a的对象引用\",{\"1\":{\"55\":1}}],[\"因为a经过objectfactory将本身提早曝光了\",{\"1\":{\"55\":1}}],[\"因为公司没了员工还在\",{\"1\":{\"33\":1}}],[\"因为干货文章的排序始终保持在最上方\",{\"1\":{\"5\":1}}],[\"因此不能解决循环依赖\",{\"1\":{\"59\":1}}],[\"因此不能解决\",{\"1\":{\"57\":1}}],[\"因此后续的依赖调用构造方法的时候并不能从三级缓存中获取到依赖的bean\",{\"1\":{\"57\":1}}],[\"因此b如今hold住的a对象完成了初始化\",{\"1\":{\"55\":1}}],[\"因此b可以经过objectfactory\",{\"1\":{\"55\":1}}],[\"因此走create流程\",{\"1\":{\"55\":1}}],[\"因此spring此时将这个对象提早曝光出来让你们认识\",{\"1\":{\"55\":1}}],[\"因此是比较合适的\",{\"1\":{\"39\":1}}],[\"因此插入和删除很慢\",{\"1\":{\"39\":1}}],[\"因此这是一种多对一的关系\",{\"1\":{\"34\":1}}],[\"因此也可以用\",{\"1\":{\"34\":1}}],[\"因此\",{\"1\":{\"7\":1,\"9\":1,\"27\":1,\"39\":1}}],[\"精简化知识点的初衷并不相符\",{\"1\":{\"7\":1}}],[\"否则可能会出现只显示文字而不显示看板娘图片的情况\",{\"1\":{\"6\":1}}],[\"juejin\",{\"1\":{\"65\":1}}],[\"just\",{\"1\":{\"47\":1}}],[\"july\",{\"1\":{\"41\":1}}],[\"july结构之法\",{\"1\":{\"41\":1}}],[\"jdkdynamicaopproxy\",{\"1\":{\"48\":2}}],[\"jdk\",{\"1\":{\"47\":1}}],[\"jdk或cglib\",{\"0\":{\"48\":1},\"1\":{\"43\":1}}],[\"jdk动态代理的案例和实现部分\",{\"1\":{\"38\":1}}],[\"jianshu\",{\"1\":{\"42\":1}}],[\"java在新窗口打开\",{\"1\":{\"40\":1}}],[\"java配置和注解方式的差异\",{\"1\":{\"38\":1}}],[\"java实现oop\",{\"1\":{\"36\":1}}],[\"javaoop基础知识总结\",{\"1\":{\"36\":1}}],[\"java\",{\"0\":{\"24\":1,\"68\":1,\"69\":1},\"1\":{\"24\":1,\"30\":1,\"31\":1,\"36\":2,\"40\":1}}],[\"json\",{\"1\":{\"16\":2}}],[\"js\",{\"1\":{\"6\":3}}],[\"jobs\",{\"1\":{\"3\":2,\"14\":1}}],[\"切换人物服饰和玩打飞机游戏\",{\"1\":{\"6\":1}}],[\"支持\",{\"1\":{\"18\":1,\"21\":1}}],[\"支持随机对话\",{\"1\":{\"6\":1}}],[\"支持非整数和负数\",{\"1\":{\"5\":1}}],[\"lazy注解解决\",{\"1\":{\"60\":1}}],[\"lazy注解\",{\"1\":{\"60\":1}}],[\"level\",{\"1\":{\"47\":1}}],[\"let\",{\"1\":{\"47\":1}}],[\"learndata\",{\"0\":{\"3\":1,\"4\":1,\"17\":1},\"1\":{\"1\":2,\"3\":4,\"5\":2,\"6\":1,\"7\":1,\"9\":1,\"11\":3,\"13\":3,\"17\":3}}],[\"log\",{\"1\":{\"63\":19}}],[\"login\",{\"1\":{\"14\":1}}],[\"lombok\",{\"1\":{\"63\":2}}],[\"low\",{\"1\":{\"47\":1}}],[\"loader\",{\"1\":{\"47\":3}}],[\"loaded\",{\"1\":{\"47\":1}}],[\"locally\",{\"1\":{\"47\":1}}],[\"localhost\",{\"1\":{\"15\":1,\"17\":1}}],[\"lock\",{\"1\":{\"16\":1}}],[\"list\",{\"1\":{\"46\":4}}],[\"list<advisor>\",{\"1\":{\"46\":8}}],[\"list<instrument>\",{\"1\":{\"28\":1}}],[\"link\",{\"1\":{\"7\":1}}],[\"live2d\",{\"1\":{\"6\":11}}],[\"版本开始\",{\"1\":{\"5\":1}}],[\"用一些工具和别人梳理的结果帮助自己构建知识体系等\",{\"1\":{\"39\":1}}],[\"用来实现一个接口\",{\"1\":{\"31\":1}}],[\"用来描述继承关系\",{\"1\":{\"30\":1}}],[\"用来存放草稿\",{\"1\":{\"5\":1}}],[\"用户无需知道对象内部的细节\",{\"1\":{\"26\":1}}],[\"用户名\",{\"1\":{\"3\":1}}],[\"上图只是给了几个例子\",{\"1\":{\"62\":1}}],[\"上文中我们知道beanfactory定义了bean容器的规范\",{\"1\":{\"51\":1}}],[\"上文中我们简单介绍了spring和spring\",{\"1\":{\"38\":1}}],[\"上文我们已经分析了ioc初始化的流程\",{\"1\":{\"52\":1}}],[\"上文我们学习了springaop\",{\"1\":{\"38\":1}}],[\"上文我们介绍了spring\",{\"1\":{\"38\":1,\"43\":1}}],[\"上文\",{\"1\":{\"38\":2,\"49\":1,\"50\":1}}],[\"上\",{\"1\":{\"5\":1,\"9\":1,\"10\":1}}],[\"区块的代码\",{\"1\":{\"14\":1}}],[\"区块\",{\"1\":{\"5\":1}}],[\"部署后\",{\"1\":{\"13\":1}}],[\"部署成功提示\",{\"1\":{\"11\":1}}],[\"部署步骤如下\",{\"1\":{\"11\":1}}],[\"部署到\",{\"0\":{\"11\":1}}],[\"部署页面路径将变为\",{\"1\":{\"3\":1}}],[\"部分删除\",{\"1\":{\"5\":1,\"15\":1}}],[\"可是已经能被人认出来了\",{\"1\":{\"55\":1}}],[\"可参考环境部署教程\",{\"1\":{\"17\":1}}],[\"可以被\",{\"1\":{\"62\":1}}],[\"可以利用\",{\"1\":{\"61\":1}}],[\"可以参考fibonacci数列\",{\"1\":{\"39\":1}}],[\"可以当做\",{\"1\":{\"27\":1}}],[\"可以继承自\",{\"1\":{\"27\":1}}],[\"可以通过剖析确定哪些模块影响了系统的性能\",{\"1\":{\"26\":1}}],[\"可以更容易被程序员理解\",{\"1\":{\"26\":1}}],[\"可以独立地开发\",{\"1\":{\"26\":1}}],[\"可以使用最新版本的\",{\"1\":{\"16\":1}}],[\"可以尝试关闭服务器防火墙\",{\"1\":{\"14\":1}}],[\"可以进入\",{\"1\":{\"14\":1}}],[\"可以删除\",{\"1\":{\"6\":1,\"14\":1}}],[\"可使用\",{\"1\":{\"14\":1}}],[\"可能是第三方插件或\",{\"1\":{\"16\":1}}],[\"可能是因为网站路径设置错误\",{\"1\":{\"13\":1}}],[\"可能需要设置子域名\",{\"1\":{\"3\":1}}],[\"可移除\",{\"1\":{\"7\":1}}],[\"可在终端中按下\",{\"1\":{\"17\":1}}],[\"可在\",{\"1\":{\"5\":1}}],[\"进去了一级缓存singletonobjects中\",{\"1\":{\"55\":1}}],[\"进而导致查询效率低下\",{\"1\":{\"39\":1}}],[\"进阶推荐\",{\"0\":{\"41\":1},\"1\":{\"39\":1}}],[\"进行销毁\",{\"1\":{\"62\":1}}],[\"进行加工操作\",{\"1\":{\"62\":1}}],[\"进行网页部署\",{\"1\":{\"11\":1}}],[\"进行全文检索\",{\"1\":{\"5\":1}}],[\"进入你的项目仓库\",{\"1\":{\"3\":1}}],[\"注意到\",{\"1\":{\"26\":1}}],[\"注意\",{\"1\":{\"5\":1}}],[\"博主个人介绍\",{\"1\":{\"5\":1}}],[\"博客文章内容\",{\"1\":{\"18\":1,\"21\":1}}],[\"博客文章样例2\",{\"0\":{\"21\":1}}],[\"博客文章样例\",{\"0\":{\"18\":1}}],[\"博客文章目录\",{\"1\":{\"5\":1}}],[\"博客\",{\"1\":{\"17\":1}}],[\"博客页面\",{\"1\":{\"5\":1}}],[\"博客汇总\",{\"1\":{\"2\":1}}],[\"博客自动化发布\",{\"1\":{\"1\":1}}],[\"id\",{\"1\":{\"62\":1}}],[\"identified\",{\"1\":{\"45\":1}}],[\"illegalstateexception\",{\"1\":{\"53\":3}}],[\"it\",{\"1\":{\"45\":1,\"53\":2}}],[\"issingletoncurrentlyincreation\",{\"1\":{\"55\":2}}],[\"issingleton\",{\"1\":{\"53\":1}}],[\"isdependent\",{\"1\":{\"53\":1}}],[\"isprototype\",{\"1\":{\"53\":1}}],[\"isprototypecurrentlyincreation\",{\"1\":{\"53\":1}}],[\"isproxyclass\",{\"1\":{\"47\":1,\"48\":1}}],[\"isproxytargetclass\",{\"1\":{\"47\":1,\"48\":2}}],[\"isinterface\",{\"1\":{\"48\":1}}],[\"isinfrastructureclass\",{\"1\":{\"45\":1}}],[\"isoptimize\",{\"1\":{\"48\":2}}],[\"isempty\",{\"1\":{\"46\":4}}],[\"is\",{\"1\":{\"26\":1,\"27\":2,\"28\":3,\"45\":3,\"46\":2,\"47\":1,\"48\":1}}],[\"ifc\",{\"1\":{\"47\":2}}],[\"if\",{\"1\":{\"26\":1,\"45\":9,\"46\":7,\"47\":9,\"48\":3,\"53\":14,\"55\":3}}],[\"i\",{\"1\":{\"17\":1,\"45\":1}}],[\"ip\",{\"1\":{\"14\":1}}],[\"implements\",{\"1\":{\"31\":1,\"63\":4}}],[\"import\",{\"1\":{\"8\":1,\"63\":10}}],[\"imgs\",{\"1\":{\"8\":3}}],[\"info\",{\"1\":{\"63\":39}}],[\"initmethod\",{\"1\":{\"63\":1}}],[\"init\",{\"1\":{\"62\":1,\"63\":2}}],[\"initializingbean\",{\"1\":{\"62\":1,\"63\":4}}],[\"innativeimage\",{\"1\":{\"48\":1}}],[\"incoming\",{\"1\":{\"46\":1}}],[\"in\",{\"1\":{\"46\":1,\"47\":2}}],[\"instantiationawarebeanpostprocessor\",{\"1\":{\"62\":2,\"63\":10}}],[\"instantiate\",{\"1\":{\"53\":1}}],[\"instanceof\",{\"1\":{\"46\":2,\"47\":2,\"53\":1}}],[\"instance\",{\"1\":{\"45\":2,\"53\":2,\"55\":2,\"63\":2}}],[\"instruments\",{\"1\":{\"28\":4}}],[\"instrument\",{\"1\":{\"28\":11}}],[\"interceptors\",{\"1\":{\"45\":1,\"46\":1,\"47\":2}}],[\"interfaces\",{\"1\":{\"47\":3}}],[\"interface\",{\"1\":{\"31\":1,\"35\":1,\"48\":1,\"55\":1,\"63\":1}}],[\"int\",{\"1\":{\"26\":3,\"63\":2}}],[\"introductions\",{\"1\":{\"47\":1}}],[\"introduction\",{\"1\":{\"47\":1}}],[\"introductionadvisor\",{\"1\":{\"46\":2}}],[\"intro\",{\"1\":{\"5\":1}}],[\"input\",{\"1\":{\"14\":1}}],[\"index\",{\"1\":{\"7\":1}}],[\"icon\",{\"1\":{\"7\":1}}],[\"ioc的初始化过程和bean的生命周期等\",{\"1\":{\"38\":1}}],[\"ioc实现原理详解之bean实例化\",{\"0\":{\"49\":1},\"1\":{\"38\":1,\"49\":1}}],[\"ioc实现原理详解之ioc初始化流程\",{\"1\":{\"38\":1}}],[\"ioc实现原理详解之ioc体系结构设计\",{\"1\":{\"38\":1}}],[\"ioc\",{\"0\":{\"75\":1},\"1\":{\"38\":2,\"62\":1}}],[\"ioc和aop\",{\"1\":{\"38\":2}}],[\"io\",{\"1\":{\"3\":3,\"6\":1,\"13\":2}}],[\"自动重新部署网站\",{\"1\":{\"13\":1}}],[\"自动重新生成并部署网页\",{\"1\":{\"3\":1}}],[\"自\",{\"1\":{\"5\":1}}],[\"自定义笔记\",{\"1\":{\"5\":1}}],[\"读书笔记中可能会有大量的原文引用\",{\"1\":{\"7\":1}}],[\"读书笔记\",{\"0\":{\"7\":1},\"1\":{\"5\":1,\"7\":1}}],[\"草稿箱\",{\"1\":{\"5\":1}}],[\"└──\",{\"1\":{\"5\":2}}],[\"导航栏\",{\"1\":{\"5\":1}}],[\"侧边栏\",{\"1\":{\"5\":1}}],[\"├──\",{\"1\":{\"5\":8}}],[\"│\",{\"1\":{\"5\":5}}],[\"字的短文\",{\"1\":{\"5\":1}}],[\"值\",{\"1\":{\"5\":1,\"62\":1}}],[\"1730527725\",{\"1\":{\"65\":1}}],[\"134\",{\"1\":{\"63\":1}}],[\"12\",{\"1\":{\"63\":20}}],[\"128\",{\"1\":{\"3\":1}}],[\"16\",{\"1\":{\"55\":2}}],[\"1是根节点\",{\"1\":{\"39\":1}}],[\"18\",{\"1\":{\"26\":1,\"63\":2}}],[\"1000\",{\"1\":{\"5\":1}}],[\"1\",{\"1\":{\"5\":1,\"8\":3,\"34\":4,\"39\":2}}],[\"99\",{\"1\":{\"5\":1}}],[\"到负无穷\",{\"1\":{\"5\":1}}],[\"到\",{\"1\":{\"5\":1}}],[\"01\",{\"1\":{\"5\":1}}],[\"0\",{\"1\":{\"5\":2,\"26\":1}}],[\"our\",{\"1\":{\"47\":1}}],[\"out\",{\"1\":{\"26\":2,\"28\":3}}],[\"on\",{\"1\":{\"53\":2}}],[\"only\",{\"1\":{\"47\":1}}],[\"one\",{\"1\":{\"45\":1}}],[\"of\",{\"1\":{\"45\":1,\"46\":5,\"47\":4,\"55\":3,\"63\":1}}],[\"overriding\",{\"1\":{\"47\":1}}],[\"override\",{\"1\":{\"45\":1,\"46\":1,\"48\":1,\"55\":1,\"63\":11}}],[\"overview\",{\"1\":{\"39\":1}}],[\"originalbeanname\",{\"1\":{\"53\":1}}],[\"original\",{\"1\":{\"47\":1}}],[\"or\",{\"1\":{\"45\":1,\"46\":1,\"47\":2,\"48\":1}}],[\"org\",{\"1\":{\"44\":1,\"63\":9}}],[\"order\",{\"1\":{\"5\":4}}],[\"o读写过于频繁\",{\"1\":{\"39\":1}}],[\"objenesiscglibaopproxy\",{\"1\":{\"48\":1}}],[\"objectfactory<object>\",{\"1\":{\"55\":1}}],[\"objectfactory<t>\",{\"1\":{\"55\":1}}],[\"objectfactory<\",{\"1\":{\"55\":3}}],[\"objectfactory\",{\"1\":{\"55\":1}}],[\"objects\",{\"1\":{\"55\":2}}],[\"object\",{\"1\":{\"45\":8,\"46\":2,\"47\":4,\"51\":5,\"53\":9,\"55\":4,\"63\":7}}],[\"object>\",{\"1\":{\"38\":1,\"49\":1,\"50\":1,\"52\":1,\"55\":4}}],[\"obsidian\",{\"1\":{\"1\":1}}],[\"o\",{\"1\":{\"32\":3}}],[\"oop\",{\"1\":{\"24\":1}}],[\"oss\",{\"1\":{\"10\":1}}],[\"文件\",{\"1\":{\"7\":1,\"16\":1}}],[\"文件中的\",{\"1\":{\"15\":1}}],[\"文件中看板娘区块代码\",{\"1\":{\"6\":1}}],[\"文件中修改文件夹路径\",{\"1\":{\"5\":1}}],[\"文件第三行的\",{\"1\":{\"6\":1}}],[\"文件夹名前缀为\",{\"1\":{\"5\":1}}],[\"文件夹\",{\"1\":{\"5\":1,\"6\":1}}],[\"文件夹默认不同步到\",{\"1\":{\"5\":1}}],[\"文件夹中\",{\"1\":{\"5\":1}}],[\"文件的\",{\"1\":{\"5\":1}}],[\"文件来生成侧边栏\",{\"1\":{\"5\":1}}],[\"文档结构\",{\"0\":{\"5\":1}}],[\"文章和页面的配置可参考主目录下的\",{\"1\":{\"5\":1}}],[\"文章\",{\"1\":{\"1\":1}}],[\"配置项的值更改为你的子路径\",{\"1\":{\"13\":1}}],[\"配置案例来调整配置\",{\"1\":{\"5\":1}}],[\"配置\",{\"0\":{\"4\":1},\"1\":{\"15\":1}}],[\"稍等几分钟再刷新页面\",{\"1\":{\"3\":1}}],[\"请浏览\",{\"1\":{\"17\":1}}],[\"请按照上方的网站部署步骤检查配置\",{\"1\":{\"14\":1}}],[\"请使用\",{\"1\":{\"11\":1}}],[\"请调整\",{\"1\":{\"7\":1}}],[\"请注意添加跨域配置\",{\"1\":{\"6\":1}}],[\"请参考\",{\"1\":{\"6\":1}}],[\"请在\",{\"1\":{\"5\":1}}],[\"请回到第三步重新触发一次\",{\"1\":{\"3\":1}}],[\"请进入菜单栏顶部的\",{\"1\":{\"3\":1}}],[\"保存在\",{\"1\":{\"8\":1}}],[\"保存\",{\"1\":{\"3\":1}}],[\"slf4j\",{\"1\":{\"63\":7}}],[\"shared\",{\"1\":{\"63\":1}}],[\"sharedinstance\",{\"1\":{\"53\":5}}],[\"shutdown\",{\"1\":{\"63\":2}}],[\"shouldproxytargetclass\",{\"1\":{\"47\":1}}],[\"shouldskip\",{\"1\":{\"45\":1}}],[\"smartclassloader\",{\"1\":{\"47\":2}}],[\"small\",{\"1\":{\"42\":1}}],[\"s\",{\"1\":{\"47\":3,\"53\":1,\"63\":4}}],[\"singletonfactory\",{\"1\":{\"55\":3}}],[\"singletonfactories\",{\"1\":{\"55\":4}}],[\"singletonobject\",{\"1\":{\"55\":8}}],[\"singletonobjects\",{\"1\":{\"55\":4}}],[\"singletons\",{\"1\":{\"53\":1}}],[\"singleton\",{\"1\":{\"53\":2,\"55\":3,\"61\":1,\"62\":1,\"63\":1}}],[\"singletontargetsource\",{\"1\":{\"45\":1}}],[\"sidebar\",{\"1\":{\"5\":2,\"7\":1}}],[\"specific\",{\"1\":{\"47\":1}}],[\"specificinterceptors\",{\"1\":{\"45\":3,\"47\":3}}],[\"springcontextshutdownhook\",{\"1\":{\"63\":2}}],[\"spring解决循环依赖主要是依赖三级缓存\",{\"1\":{\"57\":1}}],[\"spring解决循环依赖的诀窍就在于singletonfactories这个三级cache\",{\"1\":{\"55\":1}}],[\"spring首先从一级缓存singletonobjects中获取\",{\"1\":{\"55\":1}}],[\"spring首先从singletonobjects\",{\"1\":{\"55\":1}}],[\"spring只是解决了单例模式下属性依赖的循环问题\",{\"1\":{\"54\":1}}],[\"spring中bean的生命周期\",{\"0\":{\"61\":1},\"1\":{\"49\":1,\"50\":1}}],[\"spring中getbean的主体思路\",{\"0\":{\"53\":1},\"1\":{\"49\":1}}],[\"spring为了解决单例的循环依赖问题\",{\"1\":{\"54\":1}}],[\"spring为什么不能解决多例的循环依赖\",{\"0\":{\"59\":1},\"1\":{\"49\":1}}],[\"spring为什么不能解决prototype作用域循环依赖\",{\"0\":{\"58\":1},\"1\":{\"49\":1}}],[\"spring为什么不能解决构造器的循环依赖\",{\"0\":{\"57\":1},\"1\":{\"49\":1}}],[\"spring为何不能解决非单例属性之外的循环依赖\",{\"0\":{\"56\":1},\"1\":{\"49\":1}}],[\"spring单例模式下的属性依赖\",{\"0\":{\"55\":1},\"1\":{\"49\":1}}],[\"spring如何解决循环依赖问题\",{\"0\":{\"54\":1},\"1\":{\"49\":1,\"50\":1}}],[\"spring如何实现将资源配置\",{\"1\":{\"38\":1}}],[\"spring默认在目标类实现接口时是通过jdk代理实现的\",{\"1\":{\"48\":1}}],[\"springframework\",{\"1\":{\"44\":1,\"63\":30}}],[\"springmvc实现原理之dispatcherservlet处理请求的过程\",{\"1\":{\"38\":1}}],[\"springmvc实现原理之dispatcherservlet初始化的过程\",{\"1\":{\"38\":1}}],[\"springmvc请求流程和案例\",{\"1\":{\"38\":1}}],[\"spring进阶\",{\"0\":{\"43\":1,\"49\":1},\"1\":{\"38\":10,\"43\":1,\"49\":1}}],[\"spring\",{\"0\":{\"43\":1,\"49\":1,\"62\":1,\"63\":1,\"64\":1,\"70\":1},\"1\":{\"38\":8,\"43\":1,\"49\":4,\"53\":1,\"61\":8,\"62\":19}}],[\"spring核心之面向切面编程\",{\"1\":{\"38\":1}}],[\"spring核心之控制反转\",{\"1\":{\"38\":1}}],[\"spring简单例子引入spring的核心中向你展示了aop的基础含义\",{\"1\":{\"38\":1}}],[\"spring简单例子引入spring的核心中向你展示了ioc的基础含义\",{\"1\":{\"38\":1}}],[\"spring简单例子引入spring的核心\",{\"1\":{\"38\":1}}],[\"spring是什么\",{\"1\":{\"38\":1}}],[\"spring和spring框架组成\",{\"1\":{\"38\":1}}],[\"spring基础\",{\"1\":{\"38\":5}}],[\"spring的核心ioc\",{\"1\":{\"37\":1}}],[\"support\",{\"1\":{\"63\":1}}],[\"supplied\",{\"1\":{\"14\":1}}],[\"super\",{\"1\":{\"63\":5}}],[\"sublist\",{\"1\":{\"46\":2}}],[\"subclass\",{\"1\":{\"45\":1}}],[\"skywang12345\",{\"1\":{\"40\":1}}],[\"skywang12345写的数据结构\",{\"1\":{\"40\":1}}],[\"sortadvisors\",{\"1\":{\"46\":2}}],[\"sort\",{\"1\":{\"39\":2}}],[\"solid\",{\"1\":{\"36\":1}}],[\"socket\",{\"1\":{\"14\":1}}],[\"scope=\",{\"1\":{\"62\":2}}],[\"scopenotactiveexception\",{\"1\":{\"53\":1}}],[\"scopename\",{\"1\":{\"53\":5}}],[\"scopedinstance\",{\"1\":{\"53\":2}}],[\"scopes\",{\"1\":{\"53\":1}}],[\"scope\",{\"1\":{\"53\":7}}],[\"scenarios\",{\"1\":{\"47\":1}}],[\"school\",{\"1\":{\"34\":2}}],[\"screen\",{\"1\":{\"32\":2}}],[\"structure\",{\"1\":{\"40\":1}}],[\"stringvalueresolver\",{\"1\":{\"62\":1}}],[\"stringutils\",{\"1\":{\"53\":1}}],[\"string\",{\"1\":{\"26\":3,\"28\":1,\"45\":2,\"46\":2,\"47\":1,\"51\":3,\"52\":1,\"53\":11,\"55\":1,\"63\":10}}],[\"student\",{\"1\":{\"34\":2}}],[\"start\",{\"1\":{\"53\":1}}],[\"startupstep\",{\"1\":{\"53\":1}}],[\"startuml\",{\"1\":{\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1}}],[\"standard\",{\"1\":{\"53\":1}}],[\"state\",{\"1\":{\"46\":1}}],[\"static\",{\"1\":{\"28\":1,\"46\":1,\"63\":1}}],[\"system\",{\"1\":{\"26\":2,\"28\":3}}],[\"synchronized\",{\"1\":{\"55\":1}}],[\"sync\",{\"1\":{\"14\":1}}],[\"src=\",{\"1\":{\"6\":2}}],[\"setage\",{\"1\":{\"63\":4}}],[\"setapplicationcontext\",{\"1\":{\"62\":1,\"63\":3}}],[\"setname\",{\"1\":{\"63\":4}}],[\"setembeddedvalueresolver\",{\"1\":{\"62\":1}}],[\"setenvironment\",{\"1\":{\"62\":1}}],[\"setbeanfactory\",{\"1\":{\"62\":1,\"63\":3}}],[\"setbeanclassloader\",{\"1\":{\"62\":1}}],[\"setbeanname\",{\"1\":{\"62\":1,\"63\":3}}],[\"setprefiltered\",{\"1\":{\"47\":1}}],[\"setproxytargetclass\",{\"1\":{\"47\":1}}],[\"setfrozen\",{\"1\":{\"47\":1}}],[\"settargetsource\",{\"1\":{\"47\":1}}],[\"setting\",{\"1\":{\"10\":1}}],[\"settings\",{\"1\":{\"3\":3,\"47\":1}}],[\"set\",{\"1\":{\"47\":2}}],[\"see\",{\"1\":{\"45\":1,\"46\":3,\"47\":1}}],[\"search\",{\"1\":{\"39\":3}}],[\"searchpro\",{\"1\":{\"5\":1}}],[\"sequence\",{\"1\":{\"36\":1}}],[\"server\",{\"1\":{\"14\":1}}],[\"serverurl\",{\"1\":{\"7\":1}}],[\"secrets\",{\"1\":{\"10\":1}}],[\"samplepage\",{\"1\":{\"5\":1}}],[\"save\",{\"1\":{\"3\":1}}],[\"网页模板\",{\"1\":{\"5\":1}}],[\"网页显示异常\",{\"0\":{\"13\":1},\"1\":{\"3\":1}}],[\"网站部署\",{\"0\":{\"9\":1}}],[\"网站将转用本地全文索引来进行搜索\",{\"1\":{\"5\":1}}],[\"网站关键词和统计\",{\"1\":{\"5\":1}}],[\"网站环境依赖和网站属性\",{\"1\":{\"5\":1}}],[\"网站配置\",{\"1\":{\"5\":1}}],[\"网站的配置和文本都存放在\",{\"1\":{\"5\":1}}],[\"网站运行目录保持默认的\",{\"1\":{\"3\":1}}],[\"的销毁方法\",{\"1\":{\"62\":1}}],[\"的缓存池中\",{\"1\":{\"62\":1}}],[\"的作用范围为\",{\"1\":{\"62\":2}}],[\"的实例就交给客户端代码管理\",{\"1\":{\"61\":1}}],[\"的实例后\",{\"1\":{\"61\":1}}],[\"的实现过程\",{\"1\":{\"38\":1}}],[\"的生命周期管理\",{\"1\":{\"62\":1}}],[\"的生命周期流程\",{\"1\":{\"62\":1}}],[\"的生命周期是一个很复杂的执行过程\",{\"1\":{\"62\":1}}],[\"的生命周期\",{\"1\":{\"61\":2,\"62\":1}}],[\"的完整生命周期\",{\"1\":{\"61\":1}}],[\"的整个过程\",{\"1\":{\"55\":1}}],[\"的创建过程\",{\"1\":{\"43\":1,\"44\":1,\"62\":1}}],[\"的属性和方法\",{\"1\":{\"27\":1}}],[\"的高级技巧\",{\"1\":{\"17\":1}}],[\"的报错\",{\"1\":{\"16\":1}}],[\"的有效性\",{\"1\":{\"14\":1}}],[\"的速度相对\",{\"1\":{\"11\":1}}],[\"的速度不稳定\",{\"1\":{\"9\":1}}],[\"的密钥\",{\"1\":{\"10\":1}}],[\"的\",{\"1\":{\"5\":1,\"7\":1,\"61\":1,\"62\":3}}],[\"的源\",{\"1\":{\"3\":1}}],[\"的分支\",{\"1\":{\"3\":1}}],[\"将触发\",{\"1\":{\"62\":1}}],[\"将调用该方法对\",{\"1\":{\"62\":1}}],[\"将调用该接口的初始化方法\",{\"1\":{\"62\":1}}],[\"将调用该接口的预初始化方法\",{\"1\":{\"62\":1}}],[\"将调用\",{\"1\":{\"62\":1}}],[\"将当前bean实例放入alreadycreated集合里\",{\"1\":{\"53\":1}}],[\"将森林里的树逐渐合并\",{\"1\":{\"39\":1}}],[\"将结点的最低利用率从1\",{\"1\":{\"39\":1}}],[\"将切面类的所有切面方法根据使用的注解生成对应advice\",{\"1\":{\"38\":2,\"43\":1,\"44\":1}}],[\"将网页部署到云存储上\",{\"1\":{\"10\":1}}],[\"将新文档同步到\",{\"1\":{\"9\":1}}],[\"将干货类长文的\",{\"1\":{\"5\":1}}],[\"将\",{\"1\":{\"3\":1,\"6\":2,\"7\":1,\"13\":1,\"17\":1}}],[\"将我所有的笔记与文章聚合到同一页面形成知识库\",{\"1\":{\"1\":1}}],[\"中指定了该\",{\"1\":{\"62\":2}}],[\"中所有属性值的配置注入\",{\"1\":{\"62\":1}}],[\"中获取\",{\"1\":{\"55\":1}}],[\"中尝试获取\",{\"1\":{\"55\":1}}],[\"中出现\",{\"1\":{\"39\":1}}],[\"中使用\",{\"1\":{\"30\":1,\"31\":1}}],[\"中的\",{\"1\":{\"7\":1,\"11\":1,\"62\":1}}],[\"中\",{\"1\":{\"3\":1,\"14\":1,\"62\":1}}],[\"b拿到a对象后顺利完成了初始化阶段一\",{\"1\":{\"55\":1}}],[\"b在初始化第一步的时候发现本身依赖了对象a\",{\"1\":{\"55\":1}}],[\"b对象setter依赖a对象\",{\"1\":{\"55\":1}}],[\"but\",{\"1\":{\"47\":1}}],[\"buildadvisors\",{\"1\":{\"47\":2}}],[\"build\",{\"1\":{\"3\":1}}],[\"boolean\",{\"1\":{\"45\":4,\"46\":1,\"53\":1,\"55\":1,\"63\":1}}],[\"boy\",{\"1\":{\"42\":1}}],[\"by\",{\"1\":{\"45\":1,\"53\":1}}],[\"beforeprototypecreation\",{\"1\":{\"53\":2}}],[\"been\",{\"1\":{\"53\":1}}],[\"between\",{\"1\":{\"53\":1}}],[\"beta\",{\"1\":{\"5\":1}}],[\"be\",{\"1\":{\"46\":1,\"47\":2}}],[\"being\",{\"1\":{\"45\":1}}],[\"bean级生命周期接口方法\",{\"1\":{\"62\":1}}],[\"bean自身的方法\",{\"1\":{\"62\":1}}],[\"bean的完整生命周期经历了各种方法调用\",{\"1\":{\"62\":1}}],[\"beanpostprocessor\",{\"1\":{\"62\":3,\"63\":7}}],[\"beana也需要在beanb的构造函数中完成初始化\",{\"1\":{\"57\":1}}],[\"beantype\",{\"1\":{\"53\":1}}],[\"beansconfig\",{\"1\":{\"63\":1}}],[\"beans\",{\"1\":{\"53\":2,\"63\":9}}],[\"beansexception\",{\"1\":{\"51\":5,\"53\":7,\"55\":2,\"63\":9}}],[\"beancreationexception\",{\"1\":{\"53\":2}}],[\"beancreation\",{\"1\":{\"53\":5}}],[\"beancurrentlyincreationexception\",{\"1\":{\"53\":1}}],[\"beanclassloaderaware\",{\"1\":{\"62\":1}}],[\"beanclass\",{\"1\":{\"46\":5,\"47\":8,\"63\":2}}],[\"beaninstance\",{\"1\":{\"53\":6}}],[\"bean实例是否包含一个类型检查\",{\"1\":{\"53\":1}}],[\"bean生命周期源码\",{\"0\":{\"64\":1},\"1\":{\"49\":1}}],[\"bean生命周期案例\",{\"0\":{\"63\":1},\"1\":{\"49\":1}}],[\"bean生命周期流程\",{\"0\":{\"62\":1},\"1\":{\"49\":1}}],[\"beanfactorypostprocessor\",{\"1\":{\"62\":1,\"63\":3}}],[\"beanfactory实现getbean方法在abstractbeanfactory中\",{\"1\":{\"53\":1}}],[\"beanfactory中getbean的主体思路\",{\"0\":{\"51\":1},\"1\":{\"49\":1,\"50\":1}}],[\"beanfactory\",{\"1\":{\"47\":2,\"53\":1,\"63\":7}}],[\"beanfactoryaware\",{\"1\":{\"62\":2,\"63\":5}}],[\"beanfactoryaware和beanpostprocessor\",{\"1\":{\"44\":1}}],[\"beanfactoryadvisorretrievalhelper\",{\"1\":{\"46\":1}}],[\"beannameaware\",{\"1\":{\"62\":1,\"63\":4}}],[\"beanname\",{\"1\":{\"45\":10,\"46\":5,\"47\":5,\"53\":32,\"55\":9,\"63\":17}}],[\"bean\",{\"1\":{\"45\":23,\"46\":1,\"47\":7,\"53\":4,\"55\":6,\"61\":11,\"62\":33,\"63\":12}}],[\"bean加载方法栈中找到parsecustomelement方法\",{\"1\":{\"44\":1}}],[\"breadth\",{\"1\":{\"39\":1}}],[\"branch\",{\"1\":{\"3\":1}}],[\"bfs\",{\"1\":{\"39\":1}}],[\"black\",{\"1\":{\"39\":1}}],[\"blog\",{\"1\":{\"5\":1,\"36\":1,\"42\":1}}],[\"balanced\",{\"1\":{\"39\":1}}],[\"base\",{\"1\":{\"13\":5}}],[\"binary\",{\"1\":{\"39\":2}}],[\"bst\",{\"1\":{\"39\":2}}],[\"b+树总是到叶子结点才命中\",{\"1\":{\"39\":1}}],[\"b+树在b树基础上\",{\"1\":{\"39\":1}}],[\"b树+叶子有序链表\",{\"1\":{\"39\":1}}],[\"b树适用于读写相对大的数据块的存储系统\",{\"1\":{\"39\":1}}],[\"b树与自平衡二叉查找树不同\",{\"1\":{\"39\":1}}],[\"b\",{\"1\":{\"35\":5,\"39\":4,\"55\":1}}],[\"dodestroy\",{\"1\":{\"63\":4}}],[\"doinit\",{\"1\":{\"63\":4}}],[\"dogetbean\",{\"1\":{\"53\":6}}],[\"do\",{\"1\":{\"45\":1,\"46\":1}}],[\"docsify\",{\"1\":{\"7\":3}}],[\"docsearch\",{\"1\":{\"5\":1}}],[\"docs\",{\"1\":{\"5\":8,\"6\":4,\"7\":3,\"8\":2,\"13\":1,\"15\":2,\"17\":1}}],[\"docker\",{\"1\":{\"2\":2}}],[\"ds在新窗口打开\",{\"1\":{\"40\":3}}],[\"data\",{\"1\":{\"40\":1}}],[\"dashboard\",{\"1\":{\"11\":1}}],[\"dfs\",{\"1\":{\"39\":1}}],[\"d\",{\"1\":{\"39\":1}}],[\"disposablebean接口\",{\"1\":{\"63\":1}}],[\"disposablebean\",{\"1\":{\"62\":1,\"63\":4}}],[\"dispatcherservlet处理请求的过程的源码解析\",{\"1\":{\"38\":1}}],[\"dispatcherservlet的初始化过程的源码解析\",{\"1\":{\"38\":1}}],[\"dijkstra\",{\"1\":{\"39\":2}}],[\"diagram在新窗口打开\",{\"1\":{\"36\":1}}],[\"debug\",{\"1\":{\"63\":1}}],[\"demo\",{\"1\":{\"63\":1}}],[\"destroymethod\",{\"1\":{\"63\":1}}],[\"destroy\",{\"1\":{\"63\":3}}],[\"destroysingleton\",{\"1\":{\"53\":1}}],[\"destory\",{\"1\":{\"62\":2}}],[\"delegate\",{\"1\":{\"53\":1}}],[\"delegation\",{\"1\":{\"53\":1}}],[\"determine\",{\"1\":{\"46\":1,\"48\":1}}],[\"details\",{\"1\":{\"36\":1,\"42\":1}}],[\"dep\",{\"1\":{\"53\":6}}],[\"depends\",{\"1\":{\"53\":2}}],[\"dependson产生的循环依赖\",{\"1\":{\"60\":1}}],[\"dependson注解循环依赖的地方\",{\"1\":{\"60\":1}}],[\"dependson注解\",{\"1\":{\"60\":1}}],[\"dependson\",{\"1\":{\"53\":3}}],[\"dependency\",{\"0\":{\"35\":1},\"1\":{\"24\":1,\"35\":1,\"39\":1}}],[\"depth\",{\"1\":{\"39\":1}}],[\"departmentb\",{\"1\":{\"33\":2}}],[\"departmenta\",{\"1\":{\"33\":2}}],[\"deployment\",{\"1\":{\"3\":1}}],[\"dev\",{\"1\":{\"15\":1,\"17\":1}}],[\"defined\",{\"1\":{\"53\":1}}],[\"defineuserconfig\",{\"1\":{\"13\":1}}],[\"definition\",{\"1\":{\"53\":2}}],[\"defaultlistablebeanfactory\",{\"1\":{\"63\":1}}],[\"defaultaopproxyfactory\",{\"1\":{\"48\":1}}],[\"default\",{\"1\":{\"13\":1,\"47\":2}}],[\"dns\",{\"1\":{\"11\":1}}],[\"你需要安装\",{\"1\":{\"17\":1}}],[\"你需要进入项目仓库的\",{\"1\":{\"10\":1}}],[\"你也可以参考文章\",{\"1\":{\"10\":1}}],[\"你可以手动在本地建立\",{\"1\":{\"5\":1}}],[\"你可以参考注释和\",{\"1\":{\"5\":1}}],[\"你可以选择任意其他名称\",{\"1\":{\"3\":1}}],[\"你的网站将能够加载所有必要的资源文件\",{\"1\":{\"13\":1}}],[\"你的个人知识库已经成功搭建\",{\"1\":{\"3\":1}}],[\"你的用户名\",{\"1\":{\"3\":3,\"11\":1}}],[\"你将看到一个新的访问链接提示\",{\"1\":{\"3\":1}}],[\"xxx\",{\"1\":{\"3\":2,\"6\":1,\"13\":2}}],[\"have\",{\"1\":{\"53\":1}}],[\"handling\",{\"1\":{\"47\":1}}],[\"haslength\",{\"1\":{\"53\":1}}],[\"hasnousersuppliedproxyinterfaces\",{\"1\":{\"48\":2}}],[\"hasintroductions\",{\"1\":{\"46\":2}}],[\"hashmap<string\",{\"1\":{\"55\":2}}],[\"hash\",{\"1\":{\"39\":1}}],[\"hard\",{\"1\":{\"26\":1}}],[\"hubei\",{\"1\":{\"36\":1}}],[\"host\",{\"1\":{\"10\":1}}],[\"hope\",{\"1\":{\"1\":1,\"5\":1}}],[\"http\",{\"1\":{\"17\":1,\"29\":1,\"36\":1}}],[\"https\",{\"1\":{\"3\":2,\"6\":1,\"7\":2,\"11\":1,\"13\":2,\"36\":2,\"42\":3,\"65\":2}}],[\"html\",{\"1\":{\"5\":1,\"6\":1,\"7\":2,\"18\":1,\"21\":1,\"36\":2,\"42\":1}}],[\"例如给地理位置\",{\"1\":{\"39\":1}}],[\"例如磁盘\",{\"1\":{\"39\":1}}],[\"例如必须实名认证\",{\"1\":{\"9\":1}}],[\"例如文章路径为\",{\"1\":{\"5\":1}}],[\"例如\",{\"1\":{\"3\":2,\"13\":1,\"27\":1,\"39\":1}}],[\"为后面给代理进行增强实现做准备\",{\"1\":{\"44\":1}}],[\"为后续交给代理增强实现做准备的过程\",{\"1\":{\"38\":1}}],[\"为非叶子结点也增加链表指针\",{\"1\":{\"39\":1}}],[\"为叶子结点增加链表指针\",{\"1\":{\"39\":1}}],[\"为构建上层web应用\",{\"1\":{\"38\":1}}],[\"为保证国内用户访问稳定\",{\"1\":{\"11\":1}}],[\"为了本地运行\",{\"1\":{\"17\":1}}],[\"为了确保网站能够正常访问\",{\"1\":{\"9\":1}}],[\"为了避免在生成静态页面时出现\",{\"1\":{\"8\":1}}],[\"为\",{\"1\":{\"3\":1}}],[\"为此\",{\"1\":{\"1\":1}}],[\"修改文件名称\",{\"1\":{\"60\":1}}],[\"修改文件时页面会同步更新预览\",{\"1\":{\"17\":1}}],[\"修改为\",{\"1\":{\"6\":2}}],[\"修改\",{\"1\":{\"3\":1,\"13\":1}}],[\"返回beanname的实例instance\",{\"1\":{\"52\":1}}],[\"返回\",{\"1\":{\"3\":1}}],[\"并让它实现beannameaware\",{\"1\":{\"63\":1}}],[\"并将advice连同切入点匹配器和切面类等信息一并封装到advisor\",{\"1\":{\"38\":2,\"43\":1,\"44\":2}}],[\"并将其放置于\",{\"1\":{\"7\":1}}],[\"并以此引出spring的核心要点\",{\"1\":{\"38\":1}}],[\"并且不会管那些被配置成\",{\"1\":{\"61\":1}}],[\"并且更加幸运的是\",{\"1\":{\"55\":1}}],[\"并且左右两个子树都是一棵平衡二叉树\",{\"1\":{\"39\":1}}],[\"并且beandefinition接口中包含了这个类的class信息以及是否是单例等\",{\"1\":{\"38\":1,\"49\":1,\"50\":1,\"52\":1}}],[\"并且在实现时需要应用到之前拓扑排序的算法\",{\"1\":{\"39\":1}}],[\"并且在\",{\"1\":{\"28\":1}}],[\"并且在需要修改\",{\"1\":{\"26\":1}}],[\"并且在调试的时候可以不影响其他模块\",{\"1\":{\"26\":1}}],[\"并且可以通过此链接访问了\",{\"1\":{\"3\":1}}],[\"并添加\",{\"1\":{\"10\":1}}],[\"并激活\",{\"1\":{\"5\":1}}],[\"并在其中部署你的页面\",{\"1\":{\"3\":1}}],[\"并点击保存\",{\"1\":{\"3\":1}}],[\"raw\",{\"1\":{\"45\":2}}],[\"r\",{\"1\":{\"39\":2}}],[\"r树是用来做空间数据存储的树状数据结构\",{\"1\":{\"39\":1}}],[\"rockbenben\",{\"1\":{\"11\":2}}],[\"rollup\",{\"1\":{\"8\":1}}],[\"rootbeandefinition\",{\"1\":{\"53\":1}}],[\"root\",{\"1\":{\"3\":1}}],[\"run\",{\"1\":{\"3\":2,\"14\":1,\"31\":2}}],[\"retrieve\",{\"1\":{\"63\":1}}],[\"return\",{\"1\":{\"26\":2,\"45\":8,\"46\":9,\"47\":4,\"48\":3,\"53\":11,\"55\":2,\"63\":6}}],[\"received\",{\"1\":{\"53\":1}}],[\"reference\",{\"1\":{\"53\":2}}],[\"registershutdownhook\",{\"1\":{\"63\":1}}],[\"registerdependentbean\",{\"1\":{\"53\":1}}],[\"registered\",{\"1\":{\"53\":2}}],[\"relationship\",{\"1\":{\"53\":1}}],[\"repeatedly\",{\"1\":{\"47\":1}}],[\"repository\",{\"1\":{\"3\":2,\"11\":1}}],[\"removed\",{\"1\":{\"47\":1}}],[\"remove\",{\"1\":{\"45\":1,\"47\":1,\"53\":2,\"55\":1}}],[\"resolution\",{\"1\":{\"39\":1,\"53\":1}}],[\"resolve\",{\"1\":{\"8\":1}}],[\"red\",{\"1\":{\"39\":1}}],[\"realization\",{\"0\":{\"31\":1},\"1\":{\"24\":1,\"31\":1}}],[\"readme\",{\"1\":{\"6\":1}}],[\"reading\",{\"1\":{\"5\":1,\"7\":3}}],[\"read\",{\"1\":{\"3\":1,\"7\":1}}],[\"requiredtype\",{\"1\":{\"51\":3,\"53\":11}}],[\"required\",{\"1\":{\"14\":1,\"48\":1}}],[\"re\",{\"1\":{\"3\":2,\"14\":1}}],[\"页面配置\",{\"2\":{\"20\":1,\"23\":1}}],[\"页面构建和独立的读书笔记搜索索引\",{\"1\":{\"7\":1}}],[\"页面\",{\"1\":{\"3\":1,\"14\":1}}],[\"页面开发攻略和网站相关的工具和知识收集\",{\"1\":{\"2\":1}}],[\"页签\",{\"1\":{\"3\":1}}],[\"报错\",{\"1\":{\"3\":1}}],[\"在应用上下文装配配置文件之后立即调用\",{\"1\":{\"62\":1}}],[\"在其存活期间的指定时刻完成一些相关操作\",{\"1\":{\"61\":1}}],[\"在此作用域下\",{\"1\":{\"61\":1}}],[\"在此基础上还引入了不同的配置方式\",{\"1\":{\"38\":1}}],[\"在创建好交给使用者之后则不会再管理后续的生命周期\",{\"1\":{\"61\":1}}],[\"在bean建立过程当中\",{\"1\":{\"55\":1}}],[\"在b+树基础上\",{\"1\":{\"39\":1}}],[\"在b+树的非根和非叶子结点再增加指向兄弟的指针\",{\"1\":{\"39\":1}}],[\"在根结点的基础上建起一棵树\",{\"1\":{\"39\":1}}],[\"在计算机科学中\",{\"1\":{\"39\":1}}],[\"在一个增删查改比较频繁的数据结构中\",{\"1\":{\"39\":1}}],[\"在构建其知识体系时要避免自己再造轮子\",{\"1\":{\"39\":1}}],[\"在对ioc有了初步的认知后\",{\"1\":{\"38\":1}}],[\"在spring基础\",{\"1\":{\"38\":2}}],[\"在运行开始之前就可以确定\",{\"1\":{\"34\":1}}],[\"在最开始就可以确定\",{\"1\":{\"34\":1}}],[\"在终端中输入命令\",{\"1\":{\"17\":1}}],[\"在项目目录下打开终端\",{\"1\":{\"17\":1}}],[\"在你的项目中\",{\"1\":{\"13\":1}}],[\"在将\",{\"1\":{\"9\":1}}],[\"在生成静态页面后\",{\"1\":{\"7\":1}}],[\"在生成链接时将被省略\",{\"1\":{\"5\":1}}],[\"在\",{\"1\":{\"3\":1,\"28\":1,\"30\":1,\"31\":1,\"62\":1}}],[\"在页面右上方点击\",{\"1\":{\"3\":1}}],[\"在部署时能够正确访问和修改你的仓库内容\",{\"1\":{\"3\":1}}],[\"在弹出的页面中选择\",{\"1\":{\"3\":1}}],[\"pvs\",{\"1\":{\"63\":2}}],[\"ps\",{\"1\":{\"52\":1}}],[\"put\",{\"1\":{\"45\":4,\"53\":1,\"55\":1}}],[\"public\",{\"1\":{\"6\":3,\"8\":2,\"26\":4,\"28\":8,\"45\":1,\"46\":1,\"47\":1,\"48\":1,\"53\":4,\"55\":2,\"63\":24}}],[\"predestroy注解替代\",{\"1\":{\"62\":1}}],[\"predestroy注解的方法\",{\"1\":{\"62\":1}}],[\"pre\",{\"1\":{\"47\":1}}],[\"propertyvalues\",{\"1\":{\"63\":2}}],[\"prototypeinstance\",{\"1\":{\"53\":3}}],[\"prototype\",{\"1\":{\"53\":1,\"58\":1,\"61\":4,\"62\":1}}],[\"protected\",{\"1\":{\"45\":1,\"46\":3,\"47\":1,\"53\":1,\"55\":1}}],[\"processor\",{\"1\":{\"63\":6}}],[\"process\",{\"1\":{\"53\":1}}],[\"processed\",{\"1\":{\"46\":1}}],[\"proxied\",{\"1\":{\"45\":1,\"46\":1}}],[\"proxytargetclass\",{\"1\":{\"47\":1}}],[\"proxytypes\",{\"1\":{\"45\":1}}],[\"proxyfactory\",{\"1\":{\"47\":15}}],[\"proxying\",{\"1\":{\"46\":2}}],[\"proxy\",{\"1\":{\"45\":7,\"46\":2,\"47\":11,\"48\":3,\"63\":1}}],[\"print\",{\"1\":{\"63\":1}}],[\"println\",{\"1\":{\"26\":2,\"28\":3}}],[\"prim算法是从顶点出发\",{\"1\":{\"39\":1}}],[\"prim\",{\"1\":{\"39\":2}}],[\"private\",{\"1\":{\"11\":1,\"26\":3,\"27\":1,\"55\":3,\"63\":5}}],[\"p\",{\"1\":{\"36\":2,\"42\":2}}],[\"plantuml\",{\"1\":{\"29\":1}}],[\"plantuml在新窗口打开\",{\"1\":{\"29\":1}}],[\"playing\",{\"1\":{\"28\":3}}],[\"play\",{\"1\":{\"28\":7}}],[\"plugins\",{\"1\":{\"5\":1,\"15\":1}}],[\"percussion\",{\"1\":{\"28\":5}}],[\"person\",{\"1\":{\"26\":3}}],[\"permissions\",{\"1\":{\"3\":2}}],[\"pdai\",{\"1\":{\"24\":1,\"37\":1,\"39\":2,\"43\":1,\"49\":1,\"63\":29}}],[\"pnpm\",{\"1\":{\"15\":1,\"16\":1,\"17\":3}}],[\"png\",{\"1\":{\"8\":3}}],[\"post\",{\"1\":{\"65\":1}}],[\"postconstruct和\",{\"1\":{\"62\":1}}],[\"postconstruct注解的方法\",{\"1\":{\"62\":1}}],[\"postprocessproperties\",{\"1\":{\"63\":4}}],[\"postprocessafterinstantiation\",{\"1\":{\"63\":4}}],[\"postprocessafterinitialization\",{\"1\":{\"44\":1,\"45\":1,\"62\":1,\"63\":4}}],[\"postprocessbeanfactory\",{\"1\":{\"63\":3}}],[\"postprocessbeforeinitialization\",{\"1\":{\"63\":4}}],[\"postprocessbeforeinitialzation\",{\"1\":{\"62\":1}}],[\"postprocessbeforeinstantiation\",{\"1\":{\"44\":1,\"63\":4}}],[\"postprocessbeforeinstantiation和postprocessafterinitialization\",{\"1\":{\"44\":1}}],[\"posts\",{\"0\":{\"67\":1},\"1\":{\"5\":3}}],[\"pointcuts\",{\"1\":{\"46\":1}}],[\"point\",{\"1\":{\"40\":1}}],[\"port\",{\"1\":{\"10\":1}}],[\"parent\",{\"1\":{\"53\":2}}],[\"parentbeanfactory\",{\"1\":{\"53\":7}}],[\"param\",{\"1\":{\"45\":3,\"46\":4,\"47\":5,\"63\":1}}],[\"package\",{\"1\":{\"16\":1,\"63\":1}}],[\"pacakge\",{\"1\":{\"16\":1}}],[\"password\",{\"1\":{\"10\":1}}],[\"path\",{\"1\":{\"6\":2}}],[\"pages\",{\"1\":{\"3\":3,\"9\":4,\"11\":2}}],[\"page\",{\"1\":{\"3\":3}}],[\"given\",{\"1\":{\"45\":1,\"46\":2,\"47\":2}}],[\"gitee\",{\"1\":{\"9\":5}}],[\"github\",{\"1\":{\"3\":10,\"5\":1,\"6\":1,\"9\":3,\"10\":3,\"11\":3,\"13\":3,\"14\":2}}],[\"graph\",{\"1\":{\"39\":1}}],[\"gender\",{\"1\":{\"26\":6}}],[\"generalization\",{\"0\":{\"30\":1},\"1\":{\"24\":1,\"30\":1}}],[\"general\",{\"1\":{\"3\":1}}],[\"getearlybeanreference\",{\"1\":{\"55\":1}}],[\"getmessage\",{\"1\":{\"53\":1}}],[\"getmergedlocalbeandefinition\",{\"1\":{\"53\":1}}],[\"getscope\",{\"1\":{\"53\":1}}],[\"getsingleton\",{\"1\":{\"53\":2,\"55\":1}}],[\"getresourcedescription\",{\"1\":{\"53\":2}}],[\"getdependson\",{\"1\":{\"53\":1}}],[\"getparentbeanfactory\",{\"1\":{\"53\":1}}],[\"getproxy\",{\"1\":{\"47\":4}}],[\"getproxyclassloader\",{\"1\":{\"47\":1}}],[\"getobject拿到a对象\",{\"1\":{\"55\":1}}],[\"getobject\",{\"1\":{\"55\":5}}],[\"getobjectforbeaninstance\",{\"1\":{\"53\":4}}],[\"getoriginalclassloader\",{\"1\":{\"47\":1}}],[\"getbean\",{\"1\":{\"51\":5,\"52\":1,\"53\":9,\"63\":1}}],[\"gettargetclass\",{\"1\":{\"48\":1}}],[\"getinterfaces\",{\"1\":{\"47\":1}}],[\"getclassloader\",{\"1\":{\"47\":1}}],[\"getclass\",{\"1\":{\"45\":6,\"53\":1}}],[\"getcachekey\",{\"1\":{\"45\":1}}],[\"getadvicesandadvisorsforbean\",{\"1\":{\"45\":2,\"46\":1}}],[\"getgender\",{\"1\":{\"26\":1}}],[\"getname\",{\"1\":{\"26\":1}}],[\"get\",{\"0\":{\"15\":1},\"1\":{\"15\":1,\"26\":1,\"45\":1,\"53\":2,\"55\":3}}],[\"go\",{\"1\":{\"11\":1}}],[\"gh\",{\"1\":{\"3\":3,\"11\":1}}],[\"这两个接口实现\",{\"1\":{\"62\":1}}],[\"这些方法可以划分为以下几类\",{\"1\":{\"62\":1}}],[\"这类循环依赖问题可以通过使用\",{\"1\":{\"60\":1}}],[\"这类循环依赖问题可以通过把bean改成单例的解决\",{\"1\":{\"60\":1}}],[\"这类循环依赖问题要找到\",{\"1\":{\"60\":1}}],[\"这类循环依赖问题解决方法很多\",{\"1\":{\"60\":1}}],[\"这段代码发生在createbeaninstance以后\",{\"1\":{\"55\":1}}],[\"这段代码很长\",{\"1\":{\"53\":1}}],[\"这时的a就是处于建立中的状态\",{\"1\":{\"55\":1}}],[\"这里是user\",{\"1\":{\"63\":1}}],[\"这里的对象是半成品对象\",{\"1\":{\"55\":1}}],[\"这里的对象是成熟对象\",{\"1\":{\"55\":1}}],[\"这里还会包括三块重点内容\",{\"1\":{\"50\":1}}],[\"这里展示树的整体知识体系结构和几种常见树类型\",{\"1\":{\"39\":1}}],[\"这个包括了aspectjweavingenabler\",{\"1\":{\"62\":1}}],[\"这个包括了instantiationawarebeanpostprocessor\",{\"1\":{\"62\":1}}],[\"这个包括了beannameaware\",{\"1\":{\"62\":1}}],[\"这个包括了bean本身调用的方法和通过配置文件中<bean>的init\",{\"1\":{\"62\":1}}],[\"这个对象已经被生产出来了\",{\"1\":{\"55\":1}}],[\"这个cache的类型是objectfactory\",{\"1\":{\"55\":1}}],[\"这个方法很长\",{\"1\":{\"53\":1}}],[\"这个方法重载都是调用dogetbean方法进行实现的\",{\"1\":{\"53\":1}}],[\"这个方法的思路\",{\"1\":{\"52\":1}}],[\"这个类似于一个递归的数列\",{\"1\":{\"39\":1}}],[\"这个映射函数叫做散列函数\",{\"1\":{\"39\":1}}],[\"这在我们的各种管理系统\",{\"1\":{\"39\":1}}],[\"这便是springmvc\",{\"1\":{\"38\":1}}],[\"这是本文主要研究的内容\",{\"1\":{\"38\":1,\"49\":1}}],[\"这是一种静态关系\",{\"1\":{\"34\":1}}],[\"这是由评论插件\",{\"1\":{\"15\":1}}],[\"这通常发生在将仓库作为子路径部署时\",{\"1\":{\"13\":1}}],[\"这可能是\",{\"1\":{\"10\":1}}],[\"这与\",{\"1\":{\"7\":1}}],[\"这样下次获取这个单例的实例时只需要从缓存中获取\",{\"1\":{\"52\":1}}],[\"这样我们初步有了实现object\",{\"1\":{\"52\":1}}],[\"这样导致二叉查找树结构由于树的深度过大而造成磁盘i\",{\"1\":{\"39\":1}}],[\"这样\",{\"1\":{\"5\":1}}],[\"这样做可以触发\",{\"1\":{\"3\":1}}],[\"这种时刻可能有很多\",{\"1\":{\"61\":1}}],[\"这种循环依赖同样无法解决\",{\"1\":{\"58\":1}}],[\"这种情况的结果就是两个bean都不能完成初始化\",{\"1\":{\"57\":1}}],[\"这种设置使我能随时记录低于\",{\"1\":{\"5\":1}}],[\"这种方式导致我的资料分散\",{\"1\":{\"1\":1}}],[\"这一步骤是确保\",{\"1\":{\"3\":1}}],[\"选择最新的\",{\"1\":{\"3\":1}}],[\"选项\",{\"1\":{\"3\":1}}],[\"选中\",{\"1\":{\"3\":1}}],[\"设置在\",{\"1\":{\"5\":2}}],[\"设置完成后\",{\"1\":{\"3\":1}}],[\"设置\",{\"1\":{\"3\":1,\"13\":1}}],[\"we\",{\"1\":{\"47\":1}}],[\"weixin\",{\"1\":{\"36\":1}}],[\"wrapping\",{\"1\":{\"45\":1}}],[\"wrap\",{\"1\":{\"45\":1}}],[\"wrapifnecessary方法主要用于判断是否需要创建代理\",{\"1\":{\"45\":1}}],[\"wrapifnecessary\",{\"1\":{\"45\":2}}],[\"write\",{\"1\":{\"3\":1}}],[\"whz在新窗口打开\",{\"1\":{\"40\":1}}],[\"whz数据结构图画的好\",{\"1\":{\"40\":1}}],[\"wujing\",{\"1\":{\"36\":1}}],[\"www\",{\"1\":{\"36\":2,\"42\":2,\"65\":1}}],[\"woman\",{\"1\":{\"26\":1}}],[\"working\",{\"1\":{\"26\":1}}],[\"work\",{\"1\":{\"26\":3}}],[\"workflows\",{\"1\":{\"14\":1}}],[\"workflow\",{\"1\":{\"3\":3}}],[\"waline\",{\"1\":{\"7\":4,\"15\":2}}],[\"will\",{\"1\":{\"47\":1}}],[\"wind\",{\"1\":{\"28\":5,\"42\":1}}],[\"windows\",{\"1\":{\"2\":1}}],[\"widget\",{\"1\":{\"6\":8}}],[\"with\",{\"0\":{\"15\":1},\"1\":{\"3\":1,\"15\":1,\"45\":1,\"47\":1,\"53\":1}}],[\">>\",{\"1\":{\"55\":2}}],[\">的解析类是aspectjautoproxybeandefinitionparser\",{\"1\":{\"44\":1}}],[\">\",{\"1\":{\"3\":6,\"6\":2,\"10\":2,\"35\":1,\"46\":3,\"47\":2,\"48\":2,\"53\":5,\"55\":4,\"63\":1}}],[\"点击右侧按钮\",{\"1\":{\"14\":1}}],[\"点击\",{\"1\":{\"3\":1,\"11\":2}}],[\"afterpropertiesset\",{\"1\":{\"62\":1,\"63\":3}}],[\"afterprototypecreation\",{\"1\":{\"53\":2}}],[\"a此时能拿到b的对象顺利完成本身的初始化阶段二\",{\"1\":{\"55\":1}}],[\"a首先完成了初始化的第一步\",{\"1\":{\"55\":1}}],[\"a对象setter依赖b对象\",{\"1\":{\"55\":1}}],[\"abstractbeanfactory\",{\"1\":{\"53\":2}}],[\"available\",{\"1\":{\"46\":1}}],[\"avl\",{\"1\":{\"39\":3}}],[\"avl树是为了解决可能退化成链表问题\",{\"1\":{\"39\":1}}],[\"adaptbeaninstance\",{\"1\":{\"53\":1}}],[\"advice\",{\"1\":{\"47\":1}}],[\"advisedsupport\",{\"1\":{\"48\":1}}],[\"advisedbeans\",{\"1\":{\"45\":4}}],[\"advisor\",{\"1\":{\"46\":2,\"47\":1}}],[\"advisorretrievalhelper\",{\"1\":{\"46\":2}}],[\"advisorsprefiltered\",{\"1\":{\"47\":1}}],[\"advisors\",{\"1\":{\"46\":9,\"47\":2}}],[\"addsingletonfactory\",{\"1\":{\"55\":1}}],[\"added\",{\"1\":{\"47\":1}}],[\"addadvisors\",{\"1\":{\"47\":1}}],[\"addinterface\",{\"1\":{\"47\":1}}],[\"add\",{\"1\":{\"28\":2,\"46\":2,\"47\":1}}],[\"according\",{\"1\":{\"47\":1}}],[\"access\",{\"1\":{\"45\":1,\"47\":1}}],[\"action\",{\"1\":{\"3\":1,\"10\":1}}],[\"actions\",{\"1\":{\"3\":2,\"9\":1,\"10\":2,\"13\":1,\"14\":1}}],[\"aoe\",{\"1\":{\"39\":2}}],[\"aopconfigexception\",{\"1\":{\"48\":2}}],[\"aopproxy\",{\"1\":{\"48\":1}}],[\"aopnamespacehandler注册了<aop\",{\"1\":{\"44\":1}}],[\"aopnamespacehandler\",{\"1\":{\"44\":1}}],[\"aop初始化的过程\",{\"1\":{\"44\":1}}],[\"aop实现原理详解之jdk代理实现\",{\"1\":{\"38\":1}}],[\"aop实现原理详解之cglib代理实现\",{\"1\":{\"38\":1}}],[\"aop实现原理详解之aop代理的创建\",{\"0\":{\"43\":1},\"1\":{\"43\":1}}],[\"aop实现原理详解之aop代理\",{\"1\":{\"38\":1}}],[\"aop实现原理详解之切面实现\",{\"1\":{\"38\":1}}],[\"aop原理解析的切面实现过程\",{\"1\":{\"38\":2,\"43\":1,\"44\":1}}],[\"aop也是基于ioc的bean加载来实现的\",{\"1\":{\"38\":1}}],[\"aop以及springmvc的源码分析\",{\"1\":{\"38\":1}}],[\"aop的代理\",{\"1\":{\"44\":1}}],[\"aop的基础\",{\"1\":{\"38\":1}}],[\"aop的案例和具体实现机制\",{\"1\":{\"37\":1}}],[\"aop\",{\"0\":{\"74\":1},\"1\":{\"38\":1,\"44\":2,\"47\":2,\"62\":1}}],[\"assert\",{\"1\":{\"46\":1}}],[\"association\",{\"0\":{\"34\":1},\"1\":{\"24\":1,\"34\":1}}],[\"aspect注解的切面类\",{\"1\":{\"44\":1}}],[\"aspectjawareadvisorautoproxycreator实现了两类接口\",{\"1\":{\"44\":1}}],[\"aspectjautoproxybeandefinitionparser的parse\",{\"1\":{\"44\":1}}],[\"aspectj\",{\"1\":{\"44\":2}}],[\"as\",{\"1\":{\"35\":1,\"45\":2,\"46\":1}}],[\"are\",{\"1\":{\"46\":1}}],[\"article\",{\"1\":{\"36\":1,\"42\":1}}],[\"arraylist<>\",{\"1\":{\"28\":1,\"46\":1}}],[\"args\",{\"1\":{\"28\":1,\"51\":2,\"53\":15,\"63\":3}}],[\"age=18\",{\"1\":{\"63\":1}}],[\"age\",{\"1\":{\"26\":6,\"63\":6}}],[\"aggregation\",{\"0\":{\"32\":1},\"1\":{\"24\":1,\"32\":1}}],[\"author\",{\"1\":{\"63\":6}}],[\"authentication\",{\"1\":{\"14\":1}}],[\"auto\",{\"1\":{\"46\":2}}],[\"autoproxyutils\",{\"1\":{\"47\":1}}],[\"autoproxy\",{\"1\":{\"44\":1}}],[\"autoproxy的handler\",{\"1\":{\"44\":1}}],[\"autoload\",{\"1\":{\"6\":3}}],[\"application\",{\"1\":{\"63\":5}}],[\"applicationcontext\",{\"1\":{\"62\":1,\"63\":7}}],[\"applicationcontextaware接口和initializingbean\",{\"1\":{\"63\":1}}],[\"applicationcontextaware\",{\"1\":{\"62\":2,\"63\":4}}],[\"applicationstartup\",{\"1\":{\"53\":1}}],[\"applicable\",{\"1\":{\"46\":1}}],[\"apply\",{\"1\":{\"46\":1,\"47\":1}}],[\"app\",{\"1\":{\"11\":1,\"63\":4}}],[\"api\",{\"1\":{\"6\":1}}],[\"also\",{\"1\":{\"53\":1}}],[\"already\",{\"1\":{\"46\":1,\"47\":1}}],[\"alanlee\",{\"1\":{\"36\":1}}],[\"algolia\",{\"1\":{\"5\":2}}],[\"allowearlyreference\",{\"1\":{\"55\":3}}],[\"allow\",{\"1\":{\"47\":1,\"53\":1}}],[\"all\",{\"1\":{\"3\":1,\"14\":1,\"46\":2}}],[\"answer\",{\"1\":{\"65\":1}}],[\"annotationconfigapplicationcontext\",{\"1\":{\"63\":2}}],[\"an\",{\"1\":{\"46\":1,\"47\":1,\"48\":1}}],[\"animal\",{\"1\":{\"27\":7}}],[\"any\",{\"1\":{\"26\":1,\"53\":1}}],[\"anyname\",{\"1\":{\"5\":1}}],[\"and\",{\"1\":{\"3\":2,\"14\":1,\"47\":1,\"53\":1,\"63\":1}}],[\"a\",{\"1\":{\"3\":1,\"27\":2,\"35\":4,\"39\":1,\"45\":2,\"47\":1,\"48\":1,\"53\":3,\"55\":1}}],[\"cn\",{\"1\":{\"65\":1}}],[\"cnblogs\",{\"1\":{\"36\":2,\"42\":1}}],[\"circular\",{\"1\":{\"53\":2}}],[\"creating\",{\"1\":{\"63\":1}}],[\"creation\",{\"1\":{\"47\":1,\"48\":1,\"53\":1}}],[\"createbean\",{\"1\":{\"53\":3}}],[\"createaopproxy\",{\"1\":{\"47\":1,\"48\":2}}],[\"createproxy\",{\"1\":{\"45\":1,\"47\":1}}],[\"create\",{\"1\":{\"3\":1,\"11\":1,\"45\":1,\"47\":3,\"53\":1,\"63\":2}}],[\"customautowireconfigurer等等非常有用的工厂后处理器接口的方法\",{\"1\":{\"62\":1}}],[\"customizeproxyfactory\",{\"1\":{\"47\":1}}],[\"currently\",{\"1\":{\"46\":1}}],[\"checkmergedbeandefinition\",{\"1\":{\"53\":1}}],[\"check\",{\"1\":{\"53\":2}}],[\"checks\",{\"1\":{\"47\":1}}],[\"chrome\",{\"1\":{\"2\":1}}],[\"cglib\",{\"1\":{\"63\":1}}],[\"cglib或jdk\",{\"1\":{\"44\":2}}],[\"cglib动态代理的实现\",{\"1\":{\"38\":1}}],[\"cglib代理和jdk代理\",{\"1\":{\"38\":1,\"43\":1}}],[\"csdn\",{\"1\":{\"36\":1,\"42\":1}}],[\"called\",{\"1\":{\"47\":1}}],[\"cache\",{\"1\":{\"45\":1,\"53\":2,\"55\":3}}],[\"cachekey\",{\"1\":{\"45\":10}}],[\"car\",{\"1\":{\"30\":2}}],[\"catch\",{\"1\":{\"53\":4}}],[\"cat\",{\"1\":{\"27\":5}}],[\"canapply\",{\"1\":{\"46\":2}}],[\"candidate\",{\"1\":{\"46\":10}}],[\"candidateadvisors\",{\"1\":{\"46\":9}}],[\"can\",{\"1\":{\"26\":1,\"46\":1,\"47\":2}}],[\"cannot\",{\"1\":{\"16\":1,\"48\":1}}],[\"cleanupafterbeancreationfailure\",{\"1\":{\"53\":1}}],[\"clazz\",{\"1\":{\"46\":5}}],[\"class类型和参数等来得到bean实例\",{\"1\":{\"51\":1}}],[\"class为true时在目标类不是接口或者代理类时优先使用cglib代理实现\",{\"1\":{\"48\":1}}],[\"class=\",{\"1\":{\"48\":1}}],[\"classloader\",{\"1\":{\"47\":13}}],[\"class<t>\",{\"1\":{\"51\":2,\"53\":3}}],[\"class<\",{\"1\":{\"46\":3,\"47\":2,\"48\":1,\"63\":1}}],[\"class\",{\"1\":{\"26\":1,\"28\":4,\"30\":3,\"31\":2,\"32\":4,\"33\":3,\"34\":2,\"35\":1,\"46\":4,\"47\":5,\"48\":1,\"51\":1,\"63\":6}}],[\"clone\",{\"1\":{\"11\":1}}],[\"c\",{\"1\":{\"17\":1,\"39\":1}}],[\"ctrl\",{\"1\":{\"17\":1}}],[\"copyfrom\",{\"1\":{\"47\":1}}],[\"core和aop等技术基础上\",{\"1\":{\"38\":1}}],[\"counter\",{\"0\":{\"15\":1},\"1\":{\"15\":1}}],[\"concurrenthashmap<string\",{\"1\":{\"55\":1}}],[\"context\",{\"1\":{\"63\":10}}],[\"continue\",{\"1\":{\"46\":1}}],[\"containsbeandefinition\",{\"1\":{\"53\":1}}],[\"contains\",{\"1\":{\"45\":1}}],[\"container\",{\"1\":{\"38\":1}}],[\"control\",{\"1\":{\"14\":1}}],[\"const\",{\"1\":{\"6\":2}}],[\"configure\",{\"1\":{\"63\":1}}],[\"configured\",{\"1\":{\"45\":1,\"47\":1,\"63\":1}}],[\"configuration\",{\"1\":{\"63\":1}}],[\"configurationclasspostprocessor\",{\"1\":{\"62\":1}}],[\"configurablelistablebeanfactory\",{\"1\":{\"47\":2,\"63\":2}}],[\"config\",{\"1\":{\"5\":1,\"13\":1,\"44\":1,\"48\":12}}],[\"component\",{\"1\":{\"63\":3}}],[\"composition\",{\"0\":{\"33\":1},\"1\":{\"24\":1,\"33\":1}}],[\"company\",{\"1\":{\"33\":3}}],[\"computer\",{\"1\":{\"32\":4}}],[\"com\",{\"1\":{\"3\":1,\"11\":2,\"29\":1,\"36\":2,\"42\":2,\"65\":1}}],[\"code\",{\"1\":{\"3\":1,\"46\":2,\"47\":1}}],[\"按钮\",{\"1\":{\"3\":1}}],[\"typecheckonly\",{\"1\":{\"53\":3}}],[\"tag\",{\"1\":{\"53\":4}}],[\"targetclass\",{\"1\":{\"48\":4}}],[\"targets\",{\"1\":{\"47\":1}}],[\"targetsource\",{\"1\":{\"46\":2,\"47\":5,\"48\":1}}],[\"targetsourcedbeans\",{\"1\":{\"45\":1}}],[\"target\",{\"1\":{\"46\":1,\"48\":4}}],[\"table\",{\"1\":{\"39\":1}}],[\"try\",{\"1\":{\"53\":6}}],[\"transformedbeanname\",{\"1\":{\"53\":1}}],[\"true\",{\"1\":{\"45\":1,\"47\":2,\"48\":1}}],[\"truck\",{\"1\":{\"30\":2}}],[\"treap\",{\"1\":{\"39\":1}}],[\"tree\",{\"1\":{\"11\":1,\"39\":5}}],[\"trie\",{\"1\":{\"39\":3}}],[\"trie树本身是一种有限状态自动机\",{\"1\":{\"39\":1}}],[\"trie树是自然语言处理中最常用的数据结构\",{\"1\":{\"39\":1}}],[\"title\",{\"1\":{\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1}}],[\"timeout\",{\"1\":{\"14\":1}}],[\"t\",{\"1\":{\"26\":1,\"47\":1,\"51\":2,\"53\":5,\"55\":1}}],[\"tostring\",{\"1\":{\"53\":2,\"63\":3}}],[\"toarray\",{\"1\":{\"46\":1}}],[\"to\",{\"1\":{\"8\":1,\"11\":1,\"45\":1,\"46\":5,\"47\":5,\"53\":4}}],[\"topological\",{\"1\":{\"39\":2}}],[\"top\",{\"1\":{\"7\":3}}],[\"tech\",{\"1\":{\"63\":21}}],[\"text\",{\"1\":{\"7\":1}}],[\"temporary\",{\"1\":{\"53\":1}}],[\"temp\",{\"1\":{\"5\":3}}],[\"templatebuild\",{\"1\":{\"5\":1,\"6\":1}}],[\"template\",{\"1\":{\"3\":1}}],[\"ts\",{\"1\":{\"5\":7,\"7\":1,\"13\":1,\"15\":1}}],[\"throw\",{\"1\":{\"48\":1,\"53\":8}}],[\"throws\",{\"1\":{\"48\":1,\"51\":5,\"53\":5,\"55\":2,\"63\":10}}],[\"that\",{\"1\":{\"46\":2,\"47\":1,\"53\":1}}],[\"there\",{\"1\":{\"46\":1,\"53\":1}}],[\"the\",{\"1\":{\"45\":10,\"46\":12,\"47\":18,\"53\":2}}],[\"thealgorithms\",{\"1\":{\"40\":1}}],[\"theme\",{\"1\":{\"1\":1,\"5\":4,\"15\":1}}],[\"this\",{\"1\":{\"3\":1,\"45\":7,\"46\":3,\"47\":6,\"53\":2,\"55\":6,\"63\":5}}],[\"然后将切面类的所有切面方法根据使用的注解生成对应advice\",{\"1\":{\"44\":1}}],[\"然后理解数据结构中逻辑结构之树\",{\"1\":{\"39\":1}}],[\"然后点击\",{\"1\":{\"11\":1}}],[\"然后点击页面右上角的\",{\"1\":{\"3\":1}}],[\"然后会跳转至\",{\"1\":{\"11\":1}}],[\"然后\",{\"1\":{\"3\":1}}],[\"然而\",{\"1\":{\"1\":1}}],[\"访问\",{\"1\":{\"3\":1}}],[\"搭建\",{\"0\":{\"3\":1}}],[\"🍥\",{\"0\":{\"3\":1}}],[\"说明书\",{\"1\":{\"2\":1}}],[\"以及何时被销毁\",{\"1\":{\"61\":1}}],[\"以及spring如何实现将资源配置\",{\"1\":{\"38\":1,\"49\":1}}],[\"以及springmvc框架的案例和实现机制\",{\"1\":{\"37\":1}}],[\"以加快查找的速度\",{\"1\":{\"39\":1}}],[\"以xml配置为例\",{\"1\":{\"38\":2,\"49\":1,\"50\":1}}],[\"以下类图使用\",{\"1\":{\"29\":1}}],[\"以下\",{\"1\":{\"26\":1}}],[\"以创建一个基于此模板的新仓库\",{\"1\":{\"3\":1}}],[\"以分类\",{\"1\":{\"2\":1}}],[\"以\",{\"1\":{\"2\":1}}],[\"nosuchbeandefinitionexception\",{\"1\":{\"53\":1}}],[\"no\",{\"1\":{\"46\":2,\"47\":1,\"53\":3}}],[\"note\",{\"1\":{\"35\":1}}],[\"not\",{\"1\":{\"14\":1,\"16\":1,\"45\":1,\"46\":3,\"47\":2,\"53\":1,\"66\":1}}],[\"notion\",{\"1\":{\"1\":1}}],[\"null\",{\"1\":{\"45\":3,\"46\":2,\"47\":2,\"48\":1,\"53\":14,\"55\":5}}],[\"nullable\",{\"1\":{\"45\":1,\"46\":2,\"47\":3,\"53\":4}}],[\"n个节点离散分配\",{\"1\":{\"39\":1}}],[\"necessary\",{\"1\":{\"45\":1,\"47\":1}}],[\"net\",{\"1\":{\"36\":1,\"42\":1}}],[\"newzone\",{\"1\":{\"7\":3}}],[\"new\",{\"1\":{\"3\":1,\"11\":1,\"27\":1,\"28\":3,\"45\":1,\"46\":1,\"47\":2,\"48\":4,\"53\":7,\"55\":4,\"63\":4}}],[\"n\",{\"1\":{\"34\":1,\"35\":2,\"39\":5}}],[\"npm\",{\"1\":{\"17\":1}}],[\"npmrc\",{\"1\":{\"16\":1}}],[\"nativedetector\",{\"1\":{\"48\":1}}],[\"navbar\",{\"1\":{\"5\":1}}],[\"name=pdai\",{\"1\":{\"63\":1}}],[\"nametolookup\",{\"1\":{\"53\":5}}],[\"name前缀会加\",{\"1\":{\"53\":2}}],[\"name\",{\"1\":{\"3\":1,\"26\":6,\"45\":1,\"46\":1,\"47\":1,\"51\":3,\"52\":1,\"53\":19,\"55\":3,\"63\":8}}],[\"nas\",{\"1\":{\"2\":1}}],[\"服务器\",{\"1\":{\"14\":1}}],[\"服务\",{\"1\":{\"2\":1}}],[\"扩展和相关教程\",{\"1\":{\"2\":1}}],[\"软件应用\",{\"1\":{\"2\":1}}],[\"阅读\",{\"1\":{\"2\":1}}],[\"健身\",{\"1\":{\"2\":1}}],[\"日常习惯\",{\"1\":{\"2\":1}}],[\"置顶\",{\"1\":{\"2\":1}}],[\"=f\",{\"1\":{\"39\":1}}],[\"==\",{\"1\":{\"26\":1,\"48\":1,\"53\":2,\"55\":2}}],[\"=\",{\"1\":{\"1\":1,\"6\":2,\"27\":1,\"28\":1,\"45\":7,\"46\":7,\"47\":5,\"48\":1,\"53\":23,\"55\":9,\"63\":11}}],[\"+1\",{\"1\":{\"39\":1}}],[\"+f\",{\"1\":{\"39\":1}}],[\"+\",{\"1\":{\"1\":1,\"17\":1,\"26\":2,\"48\":1,\"53\":12}}],[\"笔记结构\",{\"0\":{\"2\":1}}],[\"笔记\",{\"1\":{\"1\":2}}],[\"笔记里的知识并不属于你\",{\"1\":{\"1\":1}}],[\"便于集中管理和分享\",{\"1\":{\"1\":1}}],[\"开源笔记\",{\"1\":{\"1\":1}}],[\"开源工具\",{\"1\":{\"0\":1}}],[\"我们通过一个例子来验证上面的整个流程\",{\"1\":{\"63\":1}}],[\"我们通过这个线索将知识点串联起来\",{\"1\":{\"39\":1}}],[\"我们可以利用\",{\"1\":{\"62\":1}}],[\"我们可以看下源码的实现了\",{\"1\":{\"38\":1}}],[\"我们主要看它的整体思路和设计要点\",{\"1\":{\"53\":1}}],[\"我们来看下dogetbean方法\",{\"1\":{\"53\":1}}],[\"我们看下获取所有advisor的方法getadvicesandadvisorsforbean\",{\"1\":{\"46\":1}}],[\"我们看了ioc设计要点和设计结构\",{\"1\":{\"38\":2,\"49\":1,\"50\":1}}],[\"我们经常使用的是查找和排序操作\",{\"1\":{\"39\":1}}],[\"我们便可以进一步深入理解springmvc主要实现原理\",{\"1\":{\"38\":2}}],[\"我们在前文中已经介绍了springaop的切面实现和创建动态代理的过程\",{\"1\":{\"38\":1}}],[\"我们分析了spring\",{\"1\":{\"38\":1}}],[\"我们开始对ioc的实现原理进行深入理解\",{\"1\":{\"38\":1}}],[\"我们使用\",{\"1\":{\"7\":1}}],[\"我没有选择\",{\"1\":{\"9\":1}}],[\"我已添加了详细的注释\",{\"1\":{\"5\":1}}],[\"我个人的偏好是将非干货或随想短文的\",{\"1\":{\"5\":1}}],[\"我基于\",{\"1\":{\"1\":1}}],[\"我采用了\",{\"1\":{\"1\":1}}],[\"才会成为我们的财富\",{\"1\":{\"1\":1}}],[\"难以管理和分享\",{\"1\":{\"1\":1}}],[\"飞书\",{\"1\":{\"1\":1}}],[\"和上文一样\",{\"1\":{\"46\":1}}],[\"和树的先序遍历比较类似\",{\"1\":{\"39\":1}}],[\"和操作系统的文件系统中\",{\"1\":{\"39\":1}}],[\"和关联关系不同的是\",{\"1\":{\"35\":1}}],[\"和聚合不同\",{\"1\":{\"33\":1}}],[\"和修改说明\",{\"1\":{\"6\":1}}],[\"和服务器上的后端应用\",{\"1\":{\"2\":1}}],[\"和\",{\"1\":{\"1\":2,\"10\":1,\"16\":1,\"17\":1,\"18\":1,\"21\":1,\"27\":1,\"28\":2,\"62\":6}}],[\"曾经\",{\"1\":{\"1\":1}}],[\"✨\",{\"0\":{\"1\":1}}],[\"心理学探索的自我提升笔记\",{\"1\":{\"0\":1}}],[\"效率方法\",{\"1\":{\"0\":1}}],[\"达伽马\",{\"0\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
