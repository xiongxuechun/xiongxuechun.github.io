"use strict";(self.webpackChunklearn_data=self.webpackChunklearn_data||[]).push([[903],{9168:(i,s)=>{s.A=(i,s)=>{const e=i.__vccOpts||i;for(const[i,n]of s)e[i]=n;return e}},5545:(i,s,e)=>{e.r(s),e.d(s,{comp:()=>t,data:()=>r});var n=e(6904);const a=(0,n.Fv)('<h2 id="mooncake-gate" tabindex="-1"><a class="header-anchor" href="#mooncake-gate"><span>mooncake-gate</span></a></h2><h3 id="主要功能" tabindex="-1"><a class="header-anchor" href="#主要功能"><span>主要功能</span></a></h3><p>客户端提交任务，根据任务的过期时间，判断是否需要进行持久化，然后分发到不同的topic。</p><h3 id="主要类" tabindex="-1"><a class="header-anchor" href="#主要类"><span>主要类</span></a></h3><ol><li><strong>OpenController 类</strong><ul><li><code>submit</code> 方法：接收外部任务请求，生成UUID（如果未提供），并调用 <code>submitInner</code> 方法提交任务。</li><li><code>submitInner</code> 方法：将任务分发到相应的处理器（如Kafka），并返回提交结果。</li><li><code>uuid</code> 方法：生成并返回一个新的UUID。</li><li><code>markTaskDone</code> 方法：标记任务为完成状态。</li></ul></li><li><strong>Dispatcher 接口</strong><ul><li>定义了 <code>dispatch</code> 方法，用于将任务发送到相应的处理器或持久化存储。</li></ul></li><li><strong>DispatcherImpl 类</strong><ul><li>实现了 <code>Dispatcher</code> 接口，具体实现了任务分发逻辑。</li><li><code>dispatch</code> 方法：根据任务的过期时间，将任务发送到不同的Kafka topic。</li><li><code>send</code> 方法：将任务发送到指定的Kafka topic。</li><li><code>needStore</code> 方法：判断任务是否需要持久化存储。</li></ul></li></ol><h3 id="提供的接口" tabindex="-1"><a class="header-anchor" href="#提供的接口"><span>提供的接口</span></a></h3><ul><li><code>POST /submit</code>：提交延时任务。</li><li><code>POST /inner/submit</code>：内部提交任务接口。</li><li><code>GET /uuid</code>：生成UUID。</li><li><code>POST /api/task/done</code>：标记任务完成</li></ul><h3 id="时序图" tabindex="-1"><a class="header-anchor" href="#时序图"><span>时序图</span></a></h3><div class="language-mermaid line-numbers-mode" data-highlighter="shiki" data-ext="mermaid" data-title="mermaid" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">sequenceDiagram</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant 客户端</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant OpenController</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant UidGenerator</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant Dispatcher</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant Kafka</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    客户端-&gt;&gt;OpenController: POST /submit</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    OpenController-&gt;&gt;UidGenerator: fetchRandomId (如果UUID为空)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    UidGenerator--&gt;&gt;OpenController: 返回UUID</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    OpenController-&gt;&gt;OpenController: 创建任务 (createTask)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    OpenController-&gt;&gt;Dispatcher: dispatch(task)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    Dispatcher-&gt;&gt;Kafka: 发送到持久化Topic (如果需要)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    Dispatcher-&gt;&gt;Kafka: 发送到触发持久化Topic</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    Dispatcher-&gt;&gt;Kafka: 发送到触发Topic</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    Dispatcher--&gt;&gt;OpenController: 返回分发结果</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    OpenController--&gt;&gt;客户端: ResultDTO&lt;SubmitResultVo&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    客户端-&gt;&gt;OpenController: GET /uuid</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    OpenController-&gt;&gt;UidGenerator: fetchRandomId</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    UidGenerator--&gt;&gt;OpenController: 返回UUID</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    OpenController--&gt;&gt;客户端: ResultDTO&lt;UuidResultVo&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    客户端-&gt;&gt;OpenController: POST /api/task/done</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    OpenController-&gt;&gt;ConsumerClient: done(appId, uuid)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    ConsumerClient--&gt;&gt;OpenController: 返回结果</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    OpenController--&gt;&gt;客户端: ResultDTO&lt;?&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="topic" tabindex="-1"><a class="header-anchor" href="#topic"><span>topic</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>trigger-topic: course_mooncake_trigger</span></span>\n<span class="line"><span>trigger-persistent-topic: course_mooncake_persistent</span></span>\n<span class="line"><span>triggered-persistent-topic: course_mooncake_triggered_persistent</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li><strong>persistentTask</strong>：用于持久化任务的Topic。</li><li><strong>triggeredPersistentTask</strong>：用于触发任务的Topic。</li></ol><h4 id="发送到不同topic的逻辑" tabindex="-1"><a class="header-anchor" href="#发送到不同topic的逻辑"><span>发送到不同Topic的逻辑</span></a></h4><ol><li><strong>持久化任务</strong>： <ul><li>当有新的任务需要持久化时，任务会被发送到<code>persistentTask</code> Topic。</li><li>这些任务通常是需要在未来某个时间点执行的任务。</li></ul></li><li><strong>触发任务</strong>： <ul><li>当持久化任务的执行时间到达时，任务会被发送到<code>triggeredPersistentTask </code> Topic。</li><li>这些任务是已经到达执行时间，需要立即处理的任务。</li></ul></li></ol><h4 id="不同topic的处理逻辑" tabindex="-1"><a class="header-anchor" href="#不同topic的处理逻辑"><span>不同Topic的处理逻辑</span></a></h4><ol><li><p><strong>persistentTask</strong> Topic的处理逻辑：</p><ul><li><strong>消费任务</strong>：<code>PersistentConsumer</code>会从<code>persistentTask</code> Topic中消费消息。</li><li><strong>保存到数据库</strong>：消费到的任务会被保存到数据库中，记录任务的详细信息和状态。</li><li><strong>提交偏移量</strong>：任务保存成功后，提交Kafka的消费偏移量，确保消息不会被重复消费。</li></ul></li><li><p><strong>triggeredPersistentTask</strong> Topic的处理逻辑：</p><ul><li><p><strong>消费任务</strong>：<code>PersistentConsumer</code>会从<code>triggeredPersistentTask</code> Topic中消费消息。</p></li><li><p><strong>保存到数据库</strong>：消费到的任务会被保存到数据库中，更新任务的状态为“待执行”。</p></li><li><p><strong>提交偏移量</strong>：任务保存成功后，提交Kafka的消费偏移量，确保消息不会被重复消费</p></li></ul></li></ol><h2 id="mooncake-producer" tabindex="-1"><a class="header-anchor" href="#mooncake-producer"><span>mooncake-producer</span></a></h2><ol><li><strong>Timer 类</strong><ul><li><code>Timer</code> 类负责管理时间轮的拨动和任务的添加。</li><li><code>start</code> 方法：启动定时任务，每隔一定时间拨动时间轮。</li><li><code>add</code> 方法：将任务添加到时间轮中。</li></ul></li><li><strong>TimerService 类</strong><ul><li><code>TimerService</code> 类负责管理任务的触发和消费。</li><li><code>afterPropertiesSet</code> 方法：初始化服务，启动检查点服务和触发器，并启动Kafka消费者。</li><li><code>doTrigger</code> 方法：从队列中获取任务并发送到Kafka的执行器Topic。</li><li><code>doConsume</code> 方法：从Kafka的触发Topic中消费任务，并将任务添加到检查点服务中。</li><li><code>doConsumerInner</code> 方法：具体的消费逻辑，包括分区的分配和撤销处理。</li><li><code>createLoad</code> 方法：从Kafka记录中创建任务负载对象。</li></ul></li><li><strong>TimeWheel 类</strong><ul><li><code>TimeWheel</code> 类实现了时间轮的核心逻辑，包括任务的添加和时间的推进。</li><li><code>add</code> 方法：将任务添加到时间轮中。</li><li><code>pointTo</code> 方法：推进时间轮到指定时间点，并触发过期任务。</li></ul></li><li><strong>Load 类</strong><ul><li><code>Load</code> 类表示一个任务负载，包含任务的相关信息。</li><li><code>getExpireTime</code> 方法：获取任务的过期时间。</li></ul></li><li><strong>Expired 接口</strong><ul><li><code>Expired</code> 接口定义了获取过期时间的方法。</li></ul></li><li><strong>CheckPointService 类</strong><ul><li><code>CheckPointService</code> 类负责管理检查点，确保任务的正确处理和提交。</li><li><code>start</code> 方法：启动检查点服务。</li><li><code>register</code> 方法：注册检查点。</li><li><code>deregister</code> 方法：注销检查点。</li><li><code>add</code> 方法：添加任务到检查点。</li><li><code>remove</code> 方法：从检查点移除任务。</li><li><code>doConsume</code> 方法：处理检查点的添加和移除操作。</li></ul></li><li><strong>CheckPoint 类</strong><ul><li><code>CheckPoint</code> 类表示一个检查点，管理任务的提交和标记。</li><li><code>add</code> 方法：添加任务到检查点。</li><li><code>tryMark</code> 方法：尝试标记任务为已处理。</li><li><code>tryUpdateCommitOffset</code> 方法：更新提交偏移量。</li></ul></li><li><strong>Bucket 类</strong><ul><li><code>Bucket</code> 类表示一个任务桶，管理任务的计数和最大偏移量。</li><li><code>merge</code> 方法：合并任务到桶中。</li><li><code>decrement</code> 方法：减少桶中的任务计数。</li></ul></li></ol><h3 id="提供的接口-1" tabindex="-1"><a class="header-anchor" href="#提供的接口-1"><span>提供的接口</span></a></h3><ul><li><code>TimerService</code> 类提供了任务触发和消费的核心逻辑，通过Kafka进行任务的分发和消费。</li><li><code>CheckPointService</code> 类提供了检查点的管理接口，确保任务的正确处理和提交。</li></ul><div class="language-mermaid line-numbers-mode" data-highlighter="shiki" data-ext="mermaid" data-title="mermaid" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">sequenceDiagram</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant 客户端</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant TimerService</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant Timer</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant TimeWheel</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant CheckPointService</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant Kafka</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    客户端-&gt;&gt;TimerService: 提交任务</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    TimerService-&gt;&gt;Timer: add(task)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    Timer-&gt;&gt;TimeWheel: add(task)</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    TimerService-&gt;&gt;TimerService: afterPropertiesSet()</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    TimerService-&gt;&gt;CheckPointService: start()</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    TimerService-&gt;&gt;Kafka: 启动消费者 (doConsume)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    TimerService-&gt;&gt;Kafka: 启动触发器 (doTrigger)</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    loop 每隔一定时间</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        Timer-&gt;&gt;TimeWheel: pointTo(currentTime)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    end</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    loop 消费任务</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        Kafka-&gt;&gt;TimerService: 消费任务 (doConsume)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        TimerService-&gt;&gt;CheckPointService: add(load)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    end</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    loop 触发任务</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        TimerService-&gt;&gt;Queue: take()</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        Queue--&gt;&gt;TimerService: load</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        TimerService-&gt;&gt;Kafka: 发送任务到执行器 (doTrigger)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        Kafka--&gt;&gt;TimerService: 发送成功</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        TimerService-&gt;&gt;CheckPointService: remove(load)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    end</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="系统时序图解释" tabindex="-1"><a class="header-anchor" href="#系统时序图解释"><span>系统时序图解释</span></a></h3><p>该系统时序图展示了延时任务调度系统的主要流程，包括任务的提交、时间轮的拨动、任务的消费和触发。以下是主要流程的详细描述：</p><ol><li><strong>任务提交</strong><ul><li>客户端向 <code>TimerService</code> 提交任务。</li><li><code>TimerService</code> 调用 <code>Timer</code> 的 <code>add</code> 方法，将任务添加到时间轮中。</li><li><code>Timer</code> 调用 <code>TimeWheel</code> 的 <code>add</code> 方法，将任务添加到具体的时间槽中。</li></ul></li><li><strong>系统初始化</strong><ul><li><code>TimerService</code> 调用 <code>afterPropertiesSet</code> 方法，初始化服务。</li><li><code>TimerService</code> 启动 <code>CheckPointService</code>，调用其 <code>start</code> 方法。</li><li><code>TimerService</code> 启动 Kafka 消费者，调用 <code>doConsume</code> 方法。</li><li><code>TimerService</code> 启动触发器，调用 <code>doTrigger</code> 方法。</li></ul></li><li><strong>时间轮拨动</strong><ul><li><code>Timer</code> 每隔一定时间调用 <code>TimeWheel</code> 的 <code>pointTo</code> 方法，推进时间轮到当前时间点。</li><li><code>TimeWheel</code> 检查并触发过期任务。</li></ul></li><li><strong>任务消费</strong><ul><li>Kafka 消费者从 Kafka 的触发 Topic 中消费任务，调用 <code>TimerService</code> 的 <code>doConsume</code> 方法。</li><li><code>TimerService</code> 调用 <code>CheckPointService</code> 的 <code>add</code> 方法，将任务添加到检查点服务中。</li></ul></li><li><strong>任务触发</strong><ul><li><code>TimerService</code> 从队列中获取任务，调用 <code>doTrigger</code> 方法。</li><li><code>TimerService</code> 将任务发送到 Kafka 的执行器 Topic。</li><li>Kafka 确认任务发送成功。</li><li><code>TimerService</code> 调用 <code>CheckPointService</code> 的 <code>remove</code> 方法，从检查点服务中移除任务。</li></ul></li></ol><h3 id="主要流程总结" tabindex="-1"><a class="header-anchor" href="#主要流程总结"><span>主要流程总结</span></a></h3><ul><li><strong>任务提交</strong>：客户端提交任务，任务被添加到时间轮中。</li><li><strong>系统初始化</strong>：初始化服务，启动检查点服务、Kafka 消费者和触发器。</li><li><strong>时间轮拨动</strong>：定时拨动时间轮，检查并触发过期任务。</li><li><strong>任务消费</strong>：Kafka 消费者消费任务，将任务添加到检查点服务中。</li><li><strong>任务触发</strong>：从队列中获取任务，发送到执行器，确认发送成功后从检查点服务中移除任务。</li></ul><ol><li><strong>Timer 类</strong><ul><li><code>Timer</code> 类负责管理时间轮的拨动和任务的添加。</li><li><code>start</code> 方法：启动定时任务，每隔一定时间拨动时间轮。</li><li><code>add</code> 方法：将任务添加到时间轮中。</li></ul></li><li><strong>TimerService 类</strong><ul><li><code>TimerService</code> 类负责管理任务的触发和消费。</li><li><code>afterPropertiesSet</code> 方法：初始化服务，启动检查点服务和触发器，并启动Kafka消费者。</li><li><code>doTrigger</code> 方法：从队列中获取任务并发送到Kafka的执行器Topic。</li><li><code>doConsume</code> 方法：从Kafka的触发Topic中消费任务，并将任务添加到检查点服务中。</li><li><code>doConsumerInner</code> 方法：具体的消费逻辑，包括分区的分配和撤销处理。</li><li><code>createLoad</code> 方法：从Kafka记录中创建任务负载对象。</li></ul></li><li><strong>TimeWheel 类</strong><ul><li><code>TimeWheel</code> 类实现了时间轮的核心逻辑，包括任务的添加和时间的推进。</li><li><code>add</code> 方法：将任务添加到时间轮中。</li><li><code>pointTo</code> 方法：推进时间轮到指定时间点，并触发过期任务。</li></ul></li><li><strong>Load 类</strong><ul><li><code>Load</code> 类表示一个任务负载，包含任务的相关信息。</li><li><code>getExpireTime</code> 方法：获取任务的过期时间。</li></ul></li><li><strong>Expired 接口</strong><ul><li><code>Expired</code> 接口定义了获取过期时间的方法。</li></ul></li><li><strong>CheckPointService 类</strong><ul><li><code>CheckPointService</code> 类负责管理检查点，确保任务的正确处理和提交。</li><li><code>start</code> 方法：启动检查点服务。</li><li><code>register</code> 方法：注册检查点。</li><li><code>deregister</code> 方法：注销检查点。</li><li><code>add</code> 方法：添加任务到检查点。</li><li><code>remove</code> 方法：从检查点移除任务。</li><li><code>doConsume</code> 方法：处理检查点的添加和移除操作。</li></ul></li><li><strong>CheckPoint 类</strong><ul><li><code>CheckPoint</code> 类表示一个检查点，管理任务的提交和标记。</li><li><code>add</code> 方法：添加任务到检查点。</li><li><code>tryMark</code> 方法：尝试标记任务为已处理。</li><li><code>tryUpdateCommitOffset</code> 方法：更新提交偏移量。</li></ul></li><li><strong>Bucket 类</strong><ul><li><code>Bucket</code> 类表示一个任务桶，管理任务的计数和最大偏移量。</li><li><code>merge</code> 方法：合并任务到桶中。</li><li><code>decrement</code> 方法：减少桶中的任务计数。</li></ul></li></ol><h2 id="mooncake-consumer" tabindex="-1"><a class="header-anchor" href="#mooncake-consumer"><span>mooncake-consumer</span></a></h2><p>主要实现了延时任务的消费、执行和管理。它包括了任务的HTTP请求处理、任务状态管理、任务重试机制、Redis缓存管理、以及与其他服务的通信等功能。</p><h4 id="代码分析" tabindex="-1"><a class="header-anchor" href="#代码分析"><span>代码分析</span></a></h4><ol><li><strong>TomcatAccessLogCustomizer 类</strong><ul><li>该类实现了 <code>WebServerFactoryCustomizer&lt;TomcatServletWebServerFactory&gt;</code> 接口，用于自定义 Tomcat 的访问日志配置。</li><li><code>customize</code> 方法：获取 Tomcat 的 <code>AccessLogValve</code> 并设置日志保留天数为1天。</li></ul></li><li><strong>Stage 枚举</strong><ul><li>该枚举定义了任务的不同阶段，包括 <code>TODO</code>、<code>INIT</code> 和 <code>DONE</code>。</li><li>提供了获取阶段值的方法 <code>getValue</code> 和根据值获取阶段的方法 <code>of</code>。</li></ul></li><li><strong>Props 类</strong><ul><li>该类用于读取配置文件中的 Redis 配置信息。</li><li>包含一个内部静态类 <code>Redis</code>，用于存储 Redis 地址列表。</li></ul></li><li><strong>InternalController 类</strong><ul><li>该类是一个 Spring MVC 控制器，提供了两个接口用于执行任务和标记任务完成。</li><li><code>executeTask</code> 方法：接收任务并调用 <code>CakeExecutor</code> 执行任务。</li><li><code>interceptTask</code> 方法：接收任务标识并调用 <code>CakeExecutor</code> 标记任务完成。</li></ul></li><li><strong>GateClient 接口</strong><ul><li>该接口使用 FeignClient 与 <code>mooncake-gate</code> 服务通信，提供了提交任务和获取 UUID 的接口。</li><li>包含一个内部静态类 <code>Fallback</code>，用于处理服务调用失败的情况。</li></ul></li><li><strong>CoreConfig 类</strong><ul><li>该类是一个 Spring 配置类，提供了 OkHttpClient 和 JedisCluster 的 Bean 配置。</li><li><code>okHttpClient</code> 方法：配置 OkHttpClient。</li><li><code>getJedisCluster</code> 方法：配置 JedisCluster。</li></ul></li><li><strong>TaskHandlers 类</strong><ul><li>该类用于查找并创建任务处理器。</li><li><code>find</code> 方法：根据任务创建 <code>HttpTaskHandler</code>。</li></ul></li><li><strong>TaskHandler 接口</strong><ul><li>该接口定义了任务处理器的基本方法，包括异步执行和同步执行。</li></ul></li><li><strong>HttpTaskHandler 类</strong><ul><li>该类实现了 <code>TaskHandler</code> 接口，负责处理 HTTP 任务。</li><li><code>executeAsync</code> 方法：异步执行任务。</li><li><code>execute</code> 方法：同步执行任务。</li><li><code>httpRequest</code> 方法：创建 HTTP 请求。</li><li><code>handleHttpTaskResponse</code> 方法：处理 HTTP 响应。</li></ul></li><li><strong>CakeExecutor 类</strong><ul><li>该类实现了 <code>TaskManager</code> 接口，负责任务的执行和管理。</li><li><code>mooncakeExecutor</code> 方法：Kafka 消费者，接收并处理任务。</li><li><code>tryRunTask</code> 方法：尝试执行任务。</li><li><code>handleAfterExecution</code> 方法：处理任务执行后的逻辑。</li><li><code>executeTask</code> 方法：执行任务。</li><li><code>markTaskDone</code> 方法：标记任务完成。</li></ul></li><li><strong>OkHttpService 类</strong><ul><li>该类提供了 OkHttpClient 的管理和配置。</li><li><code>client</code> 方法：根据超时时间获取 OkHttpClient。</li></ul></li></ol><h3 id="提供的接口-2" tabindex="-1"><a class="header-anchor" href="#提供的接口-2"><span>提供的接口</span></a></h3><ul><li><p>InternalController</p><p>提供了两个接口：</p><ul><li><code>/execute</code>：执行任务。</li><li><code>/done</code>：标记任务完成。</li></ul></li><li><p>GateClient</p><p>提供了两个接口：</p><ul><li><code>/inner/submit</code>：提交任务。</li><li><code>/uuid</code>：获取 UUID。</li></ul></li></ul><h3 id="系统时序图" tabindex="-1"><a class="header-anchor" href="#系统时序图"><span>系统时序图</span></a></h3><div class="language-mermaid line-numbers-mode" data-highlighter="shiki" data-ext="mermaid" data-title="mermaid" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">sequenceDiagram</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant 客户端</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant InternalController</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant CakeExecutor</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant TaskHandlers</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant HttpTaskHandler</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant GateClient</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant Redis</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant Kafka</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    客户端-&gt;&gt;InternalController: 提交任务 (executeTask)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    InternalController-&gt;&gt;CakeExecutor: executeTask(task)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    CakeExecutor-&gt;&gt;Redis: tryRunTask(task)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    Redis--&gt;&gt;CakeExecutor: 返回结果</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    CakeExecutor-&gt;&gt;TaskHandlers: find(task)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    TaskHandlers-&gt;&gt;HttpTaskHandler: 创建 HttpTaskHandler</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    HttpTaskHandler-&gt;&gt;CakeExecutor: executeAsync(commitCallback)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    HttpTaskHandler-&gt;&gt;HttpTaskHandler: 发送 HTTP 请求</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    HttpTaskHandler-&gt;&gt;CakeExecutor: handleAfterExecution(success, task)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    CakeExecutor-&gt;&gt;Redis: markTaskDone(appId, uuid)</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    客户端-&gt;&gt;InternalController: 标记任务完成 (interceptTask)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    InternalController-&gt;&gt;CakeExecutor: markTaskDone(appId, uuid)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    CakeExecutor-&gt;&gt;Redis: markTaskDone(appId, uuid)</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    Kafka-&gt;&gt;CakeExecutor: 消费任务 (mooncakeExecutor)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    CakeExecutor-&gt;&gt;Redis: tryRunTask(task)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    Redis--&gt;&gt;CakeExecutor: 返回结果</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    CakeExecutor-&gt;&gt;TaskHandlers: find(task)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    TaskHandlers-&gt;&gt;HttpTaskHandler: 创建 HttpTaskHandler</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    HttpTaskHandler-&gt;&gt;CakeExecutor: executeAsync(commitCallback)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    HttpTaskHandler-&gt;&gt;HttpTaskHandler: 发送 HTTP 请求</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    HttpTaskHandler-&gt;&gt;CakeExecutor: handleAfterExecution(success, task)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    CakeExecutor-&gt;&gt;Redis: markTaskDone(appId, uuid)</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    loop 重试任务</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        CakeExecutor-&gt;&gt;GateClient: 提交任务 (retryNextTask)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        GateClient--&gt;&gt;CakeExecutor: 返回结果</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    end</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="主要流程总结-1" tabindex="-1"><a class="header-anchor" href="#主要流程总结-1"><span>主要流程总结</span></a></h3><ul><li><strong>任务提交</strong>：客户端提交任务，任务被添加到时间轮中。</li><li><strong>系统初始化</strong>：初始化服务，启动检查点服务、Kafka 消费者和触发器。</li><li><strong>时间轮拨动</strong>：定时拨动时间轮，检查并触发过期任务。</li><li><strong>任务消费</strong>：Kafka 消费者消费任务，将任务添加到检查点服务中。</li><li><strong>任务触发</strong>：从队列中获取任务，发送到执行器，确认发送成功后从检查点服务中移除任务。</li><li><strong>任务执行</strong>：通过 HTTP 请求执行任务，处理任务执行后的逻辑，包括重试机制和任务状态管理。</li></ul><h2 id="mooncake-watcher" tabindex="-1"><a class="header-anchor" href="#mooncake-watcher"><span>mooncake-watcher</span></a></h2><p>主要实现了延时任务的持久化、分片管理、任务生命周期管理以及与其他服务的通信。它包括了任务的持久化、任务的分片管理、任务的触发和执行、任务的状态管理、以及与其他服务的通信等功能。</p><h4 id="代码分析-1" tabindex="-1"><a class="header-anchor" href="#代码分析-1"><span>代码分析</span></a></h4><ol><li><strong>InternalController 类</strong><ul><li>该类是一个 Spring MVC 控制器，提供了三个接口用于分片管理。</li><li><code>flush</code> 方法：刷新所有分片。</li><li><code>pop</code> 方法：获取指定分片的任务。</li><li><code>createShard</code> 方法：创建或更新分片总数。</li></ul></li><li><strong>PersistentConsumer 类</strong><ul><li>该类实现了 <code>InitializingBean</code> 接口，用于消费 Kafka 中的持久化任务并将其保存到数据库中。</li><li><code>afterPropertiesSet</code> 方法：启动持久化任务和触发任务的消费线程。</li><li><code>persistentTask</code> 方法：消费持久化任务并保存到数据库中。</li><li><code>triggeredPersistentTask</code> 方法：消费触发任务并保存到数据库中。</li></ul></li><li><strong>ShardManager 接口</strong><ul><li>该接口定义了分片管理的基本方法，包括获取分片配置、获取分片、填充分片和创建或更新分片总数。</li></ul></li><li><strong>ShardManagerImpl 类</strong><ul><li>该类实现了 <code>ShardManager</code> 接口，负责分片的管理。</li><li><code>afterPropertiesSet</code> 方法：初始化分片配置。</li><li><code>getShard</code> 方法：获取指定分片的任务。</li><li><code>fillShards</code> 方法：填充分片。</li><li><code>createOrUpdateShardTotal</code> 方法：创建或更新分片总数。</li></ul></li><li><strong>TaskLifeCycleManager 接口</strong><ul><li>该接口定义了任务生命周期管理的基本方法，包括刷新任务到触发器、刷新任务到消费者和清除过期任务。</li></ul></li><li><strong>TaskLifeCycleManagerImpl 类</strong><ul><li>该类实现了 <code>TaskLifeCycleManager</code> 接口，负责任务的生命周期管理。</li><li><code>flushToTrigger</code> 方法：定期将持久化任务发送到触发器。</li><li><code>flushToConsumer</code> 方法：定期将持久化任务发送到消费者。</li><li><code>flushToBin</code> 方法：定期清除过期任务。</li></ul></li><li><strong>TaskRepository 接口</strong><ul><li>该接口继承了 <code>JpaRepository</code>，用于操作数据库中的任务实体。</li><li>提供了根据状态和过期时间查询任务的方法。</li></ul></li><li><strong>TaskRepositoryHelper 类</strong><ul><li>该类提供了批量更新任务状态的方法。</li></ul></li><li><strong>Shard 类</strong><ul><li>该类表示一个分片，包含分片总数和当前分片。</li><li>提供了分片的有效性检查和分片命中判断的方法。</li></ul></li><li><strong>ShardConfigValue 类</strong><ul><li>该类表示分片配置的值，包含分片总数和分片键。</li></ul></li><li><strong>TaskEntity 类</strong><ul><li>该类表示任务实体，包含任务的基本信息和状态。</li><li>提供了初始化任务和触发任务的方法。</li></ul></li><li><strong>TaskId 类</strong><ul><li>该类表示任务的唯一标识，包含应用ID和任务ID。</li></ul></li><li><strong>ConsumerClient 接口</strong><ul><li>该接口使用 FeignClient 与 <code>mooncake-consumer</code> 服务通信，提供了执行任务的接口。</li><li>包含一个内部静态类 <code>Fallback</code>，用于处理服务调用失败的情况。</li></ul></li></ol><h3 id="提供的接口-3" tabindex="-1"><a class="header-anchor" href="#提供的接口-3"><span>提供的接口</span></a></h3><ul><li><p>InternalController</p><p>提供了三个接口：</p><ul><li><code>/shard/fill</code>：刷新所有分片。</li><li><code>/shard/pop</code>：获取指定分片的任务。</li><li><code>/shard/create</code>：创建或更新分片总数。</li></ul></li><li><p>ConsumerClient</p><p>提供了一个接口：</p><ul><li><code>/execute</code>：执行任务。</li></ul></li></ul><h3 id="系统时序图-1" tabindex="-1"><a class="header-anchor" href="#系统时序图-1"><span>系统时序图</span></a></h3><div class="language-mermaid line-numbers-mode" data-highlighter="shiki" data-ext="mermaid" data-title="mermaid" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">sequenceDiagram</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant 客户端</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant InternalController</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant ShardManager</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant PersistentConsumer</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant TaskRepository</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant Kafka</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant TaskLifeCycleManager</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant ConsumerClient</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    客户端-&gt;&gt;InternalController: 刷新分片 (flush)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    InternalController-&gt;&gt;ShardManager: fillShards(id)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    ShardManager-&gt;&gt;ShardManager: 填充分片</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    客户端-&gt;&gt;InternalController: 获取分片任务 (pop)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    InternalController-&gt;&gt;ShardManager: getShard(id)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    ShardManager-&gt;&gt;InternalController: 返回分片任务</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    客户端-&gt;&gt;InternalController: 创建分片 (createShard)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    InternalController-&gt;&gt;ShardManager: createOrUpdateShardTotal(k, total)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    ShardManager-&gt;&gt;ShardManager: 创建或更新分片总数</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    Kafka-&gt;&gt;PersistentConsumer: 消费持久化任务 (persistentTask)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    PersistentConsumer-&gt;&gt;TaskRepository: 保存任务到数据库</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    TaskRepository--&gt;&gt;PersistentConsumer: 返回结果</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    PersistentConsumer-&gt;&gt;Kafka: 提交消费偏移量</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    Kafka-&gt;&gt;PersistentConsumer: 消费触发任务 (triggeredPersistentTask)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    PersistentConsumer-&gt;&gt;TaskRepository: 保存任务到数据库</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    TaskRepository--&gt;&gt;PersistentConsumer: 返回结果</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    PersistentConsumer-&gt;&gt;Kafka: 提交消费偏移量</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    TaskLifeCycleManager-&gt;&gt;TaskRepository: 查询需要触发的任务</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    TaskRepository--&gt;&gt;TaskLifeCycleManager: 返回任务列表</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    TaskLifeCycleManager-&gt;&gt;Kafka: 发送任务到触发器 (flushToTrigger)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    Kafka--&gt;&gt;TaskLifeCycleManager: 返回结果</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    TaskLifeCycleManager-&gt;&gt;TaskRepository: 查询需要执行的任务</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    TaskRepository--&gt;&gt;TaskLifeCycleManager: 返回任务列表</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    TaskLifeCycleManager-&gt;&gt;ConsumerClient: 执行任务 (flushToConsumer)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    ConsumerClient--&gt;&gt;TaskLifeCycleManager: 返回结果</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    TaskLifeCycleManager-&gt;&gt;TaskRepository: 查询过期任务</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    TaskRepository--&gt;&gt;TaskLifeCycleManager: 返回任务列表</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    TaskLifeCycleManager-&gt;&gt;TaskRepository: 删除过期任务 (flushToBin)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    TaskRepository--&gt;&gt;TaskLifeCycleManager: 返回结果</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="主要流程总结-2" tabindex="-1"><a class="header-anchor" href="#主要流程总结-2"><span>主要流程总结</span></a></h3><ul><li><strong>分片管理</strong>：通过 <code>ShardManager</code> 实现分片的创建、更新和填充。</li><li><strong>任务持久化</strong>：通过 <code>PersistentConsumer</code> 消费 Kafka 中的持久化任务并保存到数据库中。</li><li><strong>任务生命周期管理</strong>：通过 <code>TaskLifeCycleManager</code> 定期刷新任务到触发器和消费者，并清除过期任务。</li><li><strong>任务执行</strong>：通过 <code>ConsumerClient</code> 与 <code>mooncake-consumer</code> 服务通信，执行任务。</li></ul><h2 id="mooncake-模块分析及主要流程" tabindex="-1"><a class="header-anchor" href="#mooncake-模块分析及主要流程"><span>Mooncake 模块分析及主要流程</span></a></h2><h4 id="主要模块" tabindex="-1"><a class="header-anchor" href="#主要模块"><span>主要模块</span></a></h4><ol><li><strong>InternalController</strong>：提供分片管理的接口。</li><li><strong>PersistentConsumer</strong>：消费 Kafka 中的持久化任务并保存到数据库。</li><li><strong>ShardManager</strong>：管理分片，包括获取、填充和创建/更新分片。</li><li><strong>TaskLifeCycleManager</strong>：管理任务的生命周期，包括刷新任务到触发器、消费者和清除过期任务。</li><li><strong>TaskRepository</strong>：操作数据库中的任务实体。</li><li><strong>ConsumerClient</strong>：与 <code>mooncake-consumer</code> 服务通信，执行任务。</li></ol><h4 id="主要流程" tabindex="-1"><a class="header-anchor" href="#主要流程"><span>主要流程</span></a></h4><ol><li><strong>分片管理</strong>： <ul><li>创建或更新分片总数。</li><li>获取指定分片的任务。</li><li>刷新所有分片。</li></ul></li><li><strong>任务持久化</strong>： <ul><li>消费 Kafka 中的持久化任务并保存到数据库。</li><li>消费 Kafka 中的触发任务并保存到数据库。</li></ul></li><li><strong>任务生命周期管理</strong>： <ul><li>定期将持久化任务发送到触发器。</li><li>定期将持久化任务发送到消费者。</li><li>定期清除过期任务。</li></ul></li><li><strong>任务执行</strong>： <ul><li>通过 <code>ConsumerClient</code> 与 <code>mooncake-consumer</code> 服务通信，执行任务。</li></ul></li></ol><h3 id="流程图" tabindex="-1"><a class="header-anchor" href="#流程图"><span>流程图</span></a></h3><div class="language-mermaid line-numbers-mode" data-highlighter="shiki" data-ext="mermaid" data-title="mermaid" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">flowchart TD</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    A[客户端] --&gt;|刷新分片| B[InternalController]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    B --&gt;|fillShards| C[ShardManager]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    C --&gt;|填充分片| C</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    A --&gt;|获取分片任务| B</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    B --&gt;|getShard| C</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    C --&gt;|返回分片任务| B</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    B --&gt;|返回分片任务| A</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    A --&gt;|创建分片| B</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    B --&gt;|createOrUpdateShardTotal| C</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    C --&gt;|创建或更新分片总数| C</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    D[Kafka] --&gt;|消费持久化任务| E[PersistentConsumer]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    E --&gt;|保存任务到数据库| F[TaskRepository]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    F --&gt;|返回结果| E</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    E --&gt;|提交消费偏移量| D</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    D --&gt;|消费触发任务| E</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    E --&gt;|保存任务到数据库| F</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    F --&gt;|返回结果| E</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    E --&gt;|提交消费偏移量| D</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    G[TaskLifeCycleManager] --&gt;|查询需要触发的任务| F</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    F --&gt;|返回任务列表| G</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    G --&gt;|发送任务到触发器| D</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    D --&gt;|返回结果| G</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    G --&gt;|查询需要执行的任务| F</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    F --&gt;|返回任务列表| G</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    G --&gt;|执行任务| H[ConsumerClient]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    H --&gt;|返回结果| G</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    G --&gt;|查询过期任务| F</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    F --&gt;|返回任务列表| G</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    G --&gt;|删除过期任务| F</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    F --&gt;|返回结果| G</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="时序图-1" tabindex="-1"><a class="header-anchor" href="#时序图-1"><span>时序图</span></a></h3><div class="language-mermaid line-numbers-mode" data-highlighter="shiki" data-ext="mermaid" data-title="mermaid" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">sequenceDiagram</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant 客户端</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant InternalController</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant ShardManager</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant PersistentConsumer</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant TaskRepository</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant Kafka</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant TaskLifeCycleManager</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    participant ConsumerClient</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    客户端-&gt;&gt;InternalController: 刷新分片 (flush)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    InternalController-&gt;&gt;ShardManager: fillShards(id)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    ShardManager-&gt;&gt;ShardManager: 填充分片</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    客户端-&gt;&gt;InternalController: 获取分片任务 (pop)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    InternalController-&gt;&gt;ShardManager: getShard(id)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    ShardManager-&gt;&gt;InternalController: 返回分片任务</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    客户端-&gt;&gt;InternalController: 创建分片 (createShard)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    InternalController-&gt;&gt;ShardManager: createOrUpdateShardTotal(k, total)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    ShardManager-&gt;&gt;ShardManager: 创建或更新分片总数</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    Kafka-&gt;&gt;PersistentConsumer: 消费持久化任务 (persistentTask)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    PersistentConsumer-&gt;&gt;TaskRepository: 保存任务到数据库</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    TaskRepository--&gt;&gt;PersistentConsumer: 返回结果</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    PersistentConsumer-&gt;&gt;Kafka: 提交消费偏移量</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    Kafka-&gt;&gt;PersistentConsumer: 消费触发任务 (triggeredPersistentTask)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    PersistentConsumer-&gt;&gt;TaskRepository: 保存任务到数据库</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    TaskRepository--&gt;&gt;PersistentConsumer: 返回结果</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    PersistentConsumer-&gt;&gt;Kafka: 提交消费偏移量</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    TaskLifeCycleManager-&gt;&gt;TaskRepository: 查询需要触发的任务</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    TaskRepository--&gt;&gt;TaskLifeCycleManager: 返回任务列表</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    TaskLifeCycleManager-&gt;&gt;Kafka: 发送任务到触发器 (flushToTrigger)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    Kafka--&gt;&gt;TaskLifeCycleManager: 返回结果</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    TaskLifeCycleManager-&gt;&gt;TaskRepository: 查询需要执行的任务</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    TaskRepository--&gt;&gt;TaskLifeCycleManager: 返回任务列表</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    TaskLifeCycleManager-&gt;&gt;ConsumerClient: 执行任务 (flushToConsumer)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    ConsumerClient--&gt;&gt;TaskLifeCycleManager: 返回结果</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    TaskLifeCycleManager-&gt;&gt;TaskRepository: 查询过期任务</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    TaskRepository--&gt;&gt;TaskLifeCycleManager: 返回任务列表</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    TaskLifeCycleManager-&gt;&gt;TaskRepository: 删除过期任务 (flushToBin)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    TaskRepository--&gt;&gt;TaskLifeCycleManager: 返回结果</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="主要实现细节" tabindex="-1"><a class="header-anchor" href="#主要实现细节"><span>主要实现细节</span></a></h3><ol><li><strong>InternalController</strong>： <ul><li>提供刷新分片、获取分片任务和创建分片的接口。</li><li>调用 <code>ShardManager</code> 的相应方法进行分片管理。</li></ul></li><li><strong>PersistentConsumer</strong>： <ul><li>实现 <code>InitializingBean</code> 接口，启动持久化任务和触发任务的消费线程。</li><li>消费 Kafka 中的持久化任务和触发任务，并保存到数据库中。</li></ul></li><li><strong>ShardManager</strong>： <ul><li>管理分片的创建、更新和填充。</li><li>提供获取指定分片任务的方法。</li></ul></li><li><strong>TaskLifeCycleManager</strong>： <ul><li>定期刷新任务到触发器和消费者。</li><li>定期清除过期任务。</li></ul></li><li><strong>TaskRepository</strong>： <ul><li>提供操作数据库中任务实体的方法。</li><li>提供根据状态和过期时间查询任务的方法。</li></ul></li><li><strong>ConsumerClient</strong>： <ul><li>使用 FeignClient 与 <code>mooncake-consumer</code> 服务通信，执行任务。</li></ul></li></ol><p>通过上述模块的协作，系统实现了延时任务的持久化、分片管理、任务生命周期管理和任务执行，确保任务在指定时间点被正确触发和执行，并提供了任务状态管理和分片管理机制。</p><p>你好，今晚19点04分25秒的时候，有一笔支付请求响应超时了，能帮忙看下是什么原因吗。out_trade_no是：317310638640000046083</p><p>部分请求参数如下：</p>',61),l={},t=(0,e(9168).A)(l,[["render",function(i,s){const e=(0,n.g2)("appid");return(0,n.uX)(),(0,n.CE)("div",null,[a,(0,n.bF)(e,null,{default:(0,n.k6)((()=>[(0,n.eW)("wx6830882b577925e5")])),_:1}),(0,n.eW)(" <mch_id>1641714449</mch_id> <device_info>WEB</device_info><out_trade_no>317310638640000046083</out_trade_no> <time_start>20241108190424</time_start>")])}]]),r=JSON.parse('{"path":"/%E9%A1%B9%E7%9B%AE/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97.html","title":"","lang":"zh-CN","frontmatter":{"description":"mooncake-gate 主要功能 客户端提交任务，根据任务的过期时间，判断是否需要进行持久化，然后分发到不同的topic。 主要类 OpenController 类 submit 方法：接收外部任务请求，生成UUID（如果未提供），并调用 submitInner 方法提交任务。 submitInner 方法：将任务分发到相应的处理器（如Kafka）...","head":[["meta",{"property":"og:url","content":"https://www.codenook.cn/%E9%A1%B9%E7%9B%AE/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97.html"}],["meta",{"property":"og:site_name","content":"知识体系"}],["meta",{"property":"og:description","content":"mooncake-gate 主要功能 客户端提交任务，根据任务的过期时间，判断是否需要进行持久化，然后分发到不同的topic。 主要类 OpenController 类 submit 方法：接收外部任务请求，生成UUID（如果未提供），并调用 submitInner 方法提交任务。 submitInner 方法：将任务分发到相应的处理器（如Kafka）..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-16T09:31:05.000Z"}],["meta",{"property":"article:author","content":"XIONG XUECHUN"}],["meta",{"property":"article:modified_time","content":"2024-12-16T09:31:05.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-12-16T09:31:05.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"XIONG XUECHUN\\",\\"url\\":\\"https://www.codenook.cn/\\",\\"email\\":\\"15293191747@163.com\\"}]}"]]},"headers":[{"level":2,"title":"mooncake-gate","slug":"mooncake-gate","link":"#mooncake-gate","children":[{"level":3,"title":"主要功能","slug":"主要功能","link":"#主要功能","children":[]},{"level":3,"title":"主要类","slug":"主要类","link":"#主要类","children":[]},{"level":3,"title":"提供的接口","slug":"提供的接口","link":"#提供的接口","children":[]},{"level":3,"title":"时序图","slug":"时序图","link":"#时序图","children":[]},{"level":3,"title":"topic","slug":"topic","link":"#topic","children":[]}]},{"level":2,"title":"mooncake-producer","slug":"mooncake-producer","link":"#mooncake-producer","children":[{"level":3,"title":"提供的接口","slug":"提供的接口-1","link":"#提供的接口-1","children":[]},{"level":3,"title":"系统时序图解释","slug":"系统时序图解释","link":"#系统时序图解释","children":[]},{"level":3,"title":"主要流程总结","slug":"主要流程总结","link":"#主要流程总结","children":[]}]},{"level":2,"title":"mooncake-consumer","slug":"mooncake-consumer","link":"#mooncake-consumer","children":[{"level":3,"title":"提供的接口","slug":"提供的接口-2","link":"#提供的接口-2","children":[]},{"level":3,"title":"系统时序图","slug":"系统时序图","link":"#系统时序图","children":[]},{"level":3,"title":"主要流程总结","slug":"主要流程总结-1","link":"#主要流程总结-1","children":[]}]},{"level":2,"title":"mooncake-watcher","slug":"mooncake-watcher","link":"#mooncake-watcher","children":[{"level":3,"title":"提供的接口","slug":"提供的接口-3","link":"#提供的接口-3","children":[]},{"level":3,"title":"系统时序图","slug":"系统时序图-1","link":"#系统时序图-1","children":[]},{"level":3,"title":"主要流程总结","slug":"主要流程总结-2","link":"#主要流程总结-2","children":[]}]},{"level":2,"title":"Mooncake 模块分析及主要流程","slug":"mooncake-模块分析及主要流程","link":"#mooncake-模块分析及主要流程","children":[{"level":3,"title":"流程图","slug":"流程图","link":"#流程图","children":[]},{"level":3,"title":"时序图","slug":"时序图-1","link":"#时序图-1","children":[]},{"level":3,"title":"主要实现细节","slug":"主要实现细节","link":"#主要实现细节","children":[]}]}],"git":{"createdTime":1734341465000,"updatedTime":1734341465000,"contributors":[{"name":"xiongxc","email":"xiongxc@rd.netease.com","commits":1}]},"readingTime":{"minutes":18.17,"words":5452},"filePathRelative":"项目/支付系统/延迟队列.md","localizedDate":"2024年12月16日","excerpt":"<h2>mooncake-gate</h2>\\n<h3>主要功能</h3>\\n<p>客户端提交任务，根据任务的过期时间，判断是否需要进行持久化，然后分发到不同的topic。</p>\\n<h3>主要类</h3>\\n<ol>\\n<li><strong>OpenController 类</strong>\\n<ul>\\n<li><code>submit</code> 方法：接收外部任务请求，生成UUID（如果未提供），并调用 <code>submitInner</code> 方法提交任务。</li>\\n<li><code>submitInner</code> 方法：将任务分发到相应的处理器（如Kafka），并返回提交结果。</li>\\n<li><code>uuid</code> 方法：生成并返回一个新的UUID。</li>\\n<li><code>markTaskDone</code> 方法：标记任务为完成状态。</li>\\n</ul>\\n</li>\\n<li><strong>Dispatcher 接口</strong>\\n<ul>\\n<li>定义了 <code>dispatch</code> 方法，用于将任务发送到相应的处理器或持久化存储。</li>\\n</ul>\\n</li>\\n<li><strong>DispatcherImpl 类</strong>\\n<ul>\\n<li>实现了 <code>Dispatcher</code> 接口，具体实现了任务分发逻辑。</li>\\n<li><code>dispatch</code> 方法：根据任务的过期时间，将任务发送到不同的Kafka topic。</li>\\n<li><code>send</code> 方法：将任务发送到指定的Kafka topic。</li>\\n<li><code>needStore</code> 方法：判断任务是否需要持久化存储。</li>\\n</ul>\\n</li>\\n</ol>","autoDesc":true}')}}]);