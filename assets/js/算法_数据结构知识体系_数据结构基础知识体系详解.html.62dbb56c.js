"use strict";(self.webpackChunklearn_data=self.webpackChunklearn_data||[]).push([[8499],{9168:(l,e)=>{e.A=(l,e)=>{const a=l.__vccOpts||l;for(const[l,t]of e)a[l]=t;return a}},6382:(l,e,a)=>{a.r(e),a.d(e,{comp:()=>T,data:()=>x});var t=a(6904);const i=(0,t.Lk)("h1",{id:"♥数据结构基础知识体系详解♥",tabindex:"-1"},[(0,t.Lk)("a",{class:"header-anchor",href:"#♥数据结构基础知识体系详解♥"},[(0,t.Lk)("span",null,[(0,t.Lk)("a",{href:"#%E2%99%A5%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3%E2%99%A5"},"#"),(0,t.eW)(" ♥数据结构基础知识体系详解♥")])])],-1),r=(0,t.Lk)("p",null,"提示",-1),o=(0,t.Lk)("p",null,"对于数据结构这种基础内容，在构建其知识体系时要避免自己再造轮子，需要高一点层次整体上去理解它(格局要大一点，不要盯着代码)，要了解算法思想，性能及适用场景，用一些工具和别人梳理的结果帮助自己构建知识体系等。@pdai",-1),n=(0,t.Lk)("a",{href:"#%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB"},"#",-1),u=(0,t.Fv)('<hr><p><em>知识体系系统性梳理</em></p><figure><img src="https://pdai.tech/images/alg/alg-overview-x.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><em>学习思路</em></p><blockquote><p>避免孤立的学习知识点，要关联学习。比如实际应用当中，我们经常使用的是<code>查找</code>和<code>排序</code>操作，这在我们的各种管理系统、数据库系统、操作系统等当中，十分常用，我们通过这个线索将知识点串联起来：</p></blockquote><p><code>数组</code>的下标寻址十分迅速，但计算机的内存是有限的，故数组的长度也是有限的，实际应用当中的数据往往十分庞大；而且无序数组的查找最坏情况需要遍历整个数组；后来人们提出了二分查找，二分查找要求数组的构造一定有序，二分法查找解决了普通数组查找复杂度过高的问题。任何一种数组无法解决的问题就是插入、删除操作比较复杂，因此，在一个增删查改比较频繁的数据结构中，数组不会被优先考虑</p><p><code>普通链表</code>由于它的结构特点被证明根本不适合进行查找</p><p><code>哈希表</code>是数组和链表的折中，同时它的设计依赖散列函数的设计，数组不能无限长、链表也不适合查找，所以也不适合大规模的查找</p><p><code>二叉查找树</code>因为可能退化成链表，同样不适合进行查找</p><p><code>AVL树</code>是为了解决可能退化成链表问题，但是AVL树的旋转过程非常麻烦，因此插入和删除很慢，也就是构建AVL树比较麻烦</p><p><code>红黑树</code>是平衡二叉树和AVL树的折中，因此是比较合适的。集合类中的Map、关联数组具有较高的查询效率，它们的底层实现就是红黑树。</p><p><code>多路查找树</code> 是大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的(如果元素数量非常多的话，查找就退化成节点内部的线性查找了)，这样导致二叉查找树结构由于树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下。</p><p><code>B树</code>与自平衡二叉查找树不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。它的应用是文件系统及部分非关系型数据库索引。</p><p><code>B+树</code>在B树基础上，为叶子结点增加链表指针(B树+叶子有序链表)，所有关键字都在叶子结点 中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中。通常用于关系型数据库(如Mysql)和操作系统的文件系统中。</p><p><code>B*树</code>是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针, 在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3。</p><p><code>R树</code>是用来做空间数据存储的树状数据结构。例如给地理位置，矩形和多边形这类多维数据建立索引。</p><p><code>Trie树</code>是自然语言处理中最常用的数据结构，很多字符串处理任务都会用到。Trie树本身是一种有限状态自动机，还有很多变体。什么模式匹配、正则表达式，都与这有关。</p><p><em>相关文章</em></p><blockquote><p><strong>A. 数据结构 知识点</strong>：数据结构是基础中的基础，任何进阶都逃不开这些知识点。</p></blockquote>',19),c=(0,t.Lk)("blockquote",null,[(0,t.Lk)("p",null,[(0,t.Lk)("strong",null,"B. 数据结构之 线性结构"),(0,t.eW)("：首先理解数据结构中线性结构及其延伸：数组和矩阵，链表，栈和队列等。")])],-1),h=(0,t.Lk)("ul",null,[(0,t.Lk)("li",null,"数组是一种连续存储线性结构，元素类型相同，大小相等，数组是多维的，通过使用整型索引值来访问他们的元素，数组尺寸不能改变")],-1),p=(0,t.Lk)("ul",null,[(0,t.Lk)("li",null,"n个节点离散分配，彼此通过指针相连，每个节点只有一个前驱节点，每个节点只有一个后续节点，首节点没有前驱节点，尾节点没有后续节点。确定一个链表我们只需要头指针，通过头指针就可以把整个链表都能推出来")],-1),d=(0,t.Lk)("ul",null,[(0,t.Lk)("li",null,"散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。@pdai")],-1),m=(0,t.Lk)("ul",null,[(0,t.Lk)("li",null,"数组和链表都是线性存储结构的基础，栈和队列都是线性存储结构的应用")],-1),s=(0,t.Lk)("blockquote",null,[(0,t.Lk)("p",null,[(0,t.Lk)("strong",null,"C. 数据结构之 逻辑结构：树"),(0,t.eW)("：然后理解数据结构中逻辑结构之树：二叉搜索树(BST)，平衡二叉树(AVL)，红黑树(R-B Tree)，哈夫曼树，前缀树(Trie)等。")])],-1),k=(0,t.Lk)("ul",null,[(0,t.Lk)("li",null,"树在数据结构中至关重要，这里展示树的整体知识体系结构和几种常见树类型")],-1),E=(0,t.Lk)("ul",null,[(0,t.Lk)("li",null,"本文主要介绍 二叉树中最基本的二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。")],-1),g=(0,t.Lk)("ul",null,[(0,t.Lk)("li",null,"平衡二叉树（Balanced Binary Tree）具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。 最小二叉平衡树的节点的公式如下 F(n)=F(n-1)+F(n-2)+1 这个类似于一个递归的数列，可以参考Fibonacci数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。")],-1),B=(0,t.Lk)("ul",null,[(0,t.Lk)("li",null,"红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组，是平衡二叉树和AVL树的折中。")],-1),b=(0,t.Lk)("ul",null,[(0,t.Lk)("li",null,"哈夫曼又称最优二叉树, 是一种带权路径长度最短的二叉树。")],-1),L=(0,t.Lk)("ul",null,[(0,t.Lk)("li",null,"Trie，又称字典树、单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。")],-1),A=(0,t.Lk)("blockquote",null,[(0,t.Lk)("p",null,[(0,t.Lk)("strong",null,"D. 数据结构之 逻辑结构：图"),(0,t.eW)("：最后理解数据结构中逻辑结构之图：图基础，图的遍历，最小生成树(Prim & Kruskal)，最短路径(Dijkstra & Frolyd)，拓扑排序(Topological sort)，AOE & 关键路径等。")])],-1),f=(0,t.Lk)("ul",null,[(0,t.Lk)("li",null,"图(Graph)是由顶点和连接顶点的边构成的离散结构。在计算机科学中，图是最灵活的数据结构之一，很多问题都可以使用图模型进行建模求解。例如: 生态环境中不同物种的相互竞争、人与人之间的社交与关系网络、化学上用图区分结构不同但分子式相同的同分异构体、分析计算机网络的拓扑结构确定两台计算机是否可以通信、找到两个城市之间的最短路径等等。")],-1),F=(0,t.Lk)("ul",null,[(0,t.Lk)("li",null,'图的深度优先搜索(Depth First Search)，和树的先序遍历比较类似; 广度优先搜索算法(Breadth First Search)，又称为"宽度优先搜索"或"横向优先搜索"')],-1),w=(0,t.Lk)("ul",null,[(0,t.Lk)("li",null,"Kruskal算法是从最小权重边着手，将森林里的树逐渐合并；prim算法是从顶点出发，在根结点的基础上建起一棵树")],-1),v=(0,t.Lk)("ul",null,[(0,t.Lk)("li",null,"最短路径有着广泛的应用，比如地图两点间距离计算，公交查询系统，路由选择等")],-1),_=(0,t.Lk)("ul",null,[(0,t.Lk)("li",null,"拓扑排序主要用来解决有向图中的依赖解析(dependency resolution)问题")],-1),D=(0,t.Lk)("ul",null,[(0,t.Lk)("li",null,"关键路径在项目管理计算工期等方面有广泛等应用，提升工期就是所见缩减所有关键路径上的工期，并且在实现时需要应用到之前拓扑排序的算法(前提: 有向无环图，有依赖关系)")],-1),y=(0,t.Fv)('<h2 id="入门推荐" tabindex="-1"><a class="header-anchor" href="#入门推荐"><span><a href="#%E5%85%A5%E9%97%A8%E6%8E%A8%E8%8D%90">#</a> 入门推荐</span></a></h2><ul><li>强烈推荐用动画学习算法 <a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener noreferrer">Data Structure Visualizations在新窗口打开</a></li><li>推荐一个学习数据结构的英文网站 <a href="https://www.javatpoint.com/data-structure-tutorial" target="_blank" rel="noopener noreferrer">Java Point - DS在新窗口打开</a></li><li>推荐Github上java算法集合 <a href="https://github.com/TheAlgorithms/Java" target="_blank" rel="noopener noreferrer">TheAlgorithms - Java在新窗口打开</a></li><li>推荐@skywang12345写的数据结构 <a href="https://www.cnblogs.com/skywang12345/p/3603935.html" target="_blank" rel="noopener noreferrer">skywang12345 - DS在新窗口打开</a></li><li>推荐@QG-whz数据结构图画的好(本章节中有部分图源于这位作者) <a href="https://www.cnblogs.com/QG-whz/p/5170147.html" target="_blank" rel="noopener noreferrer">QG-whz在新窗口打开</a></li><li>推荐@亦海数据结构的文章，写的很清晰 <a href="https://www.cnblogs.com/lisen10/category/1415992.html" target="_blank" rel="noopener noreferrer">亦海 - DS在新窗口打开</a></li></ul><h2 id="进阶推荐" tabindex="-1"><a class="header-anchor" href="#进阶推荐"><span><a href="#%E8%BF%9B%E9%98%B6%E6%8E%A8%E8%8D%90">#</a> 进阶推荐</span></a></h2><ul><li>首推@July结构之法 算法之道 <a href="https://blog.csdn.net/v_JULY_v" target="_blank" rel="noopener noreferrer">July - 结构之法 算法之道在新窗口打开</a></li></ul><h2 id="参考文章" tabindex="-1"><a class="header-anchor" href="#参考文章"><span><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0">#</a> 参考文章</span></a></h2><ul><li>https://www.cnblogs.com/small-boy/p/8039007.html</li><li>https://www.jianshu.com/p/5c84f7b6c354</li><li>https://blog.csdn.net/flowing_wind/article/details/81431354</li></ul>',6),W={},T=(0,a(9168).A)(W,[["render",function(l,e){const a=(0,t.g2)("RouteLink");return(0,t.uX)(),(0,t.CE)("div",null,[i,r,o,(0,t.Lk)("ul",null,[(0,t.Lk)("li",null,[(0,t.bF)(a,{to:"/md/algorithm/alg-basic-overview.html#%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB"},{default:(0,t.k6)((()=>[(0,t.eW)("知识体系")])),_:1})]),(0,t.Lk)("li",null,[(0,t.bF)(a,{to:"/md/algorithm/alg-basic-overview.html#%E5%85%A5%E9%97%A8%E6%8E%A8%E8%8D%90"},{default:(0,t.k6)((()=>[(0,t.eW)("入门推荐")])),_:1})]),(0,t.Lk)("li",null,[(0,t.bF)(a,{to:"/md/algorithm/alg-basic-overview.html#%E8%BF%9B%E9%98%B6%E6%8E%A8%E8%8D%90"},{default:(0,t.k6)((()=>[(0,t.eW)("进阶推荐")])),_:1})]),(0,t.Lk)("li",null,[(0,t.bF)(a,{to:"/md/algorithm/alg-basic-overview.html#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"},{default:(0,t.k6)((()=>[(0,t.eW)("参考文章")])),_:1}),n,(0,t.eW)(" 知识体系")])]),u,(0,t.Lk)("ul",null,[(0,t.Lk)("li",null,[(0,t.bF)(a,{to:"/md/algorithm/alg-basic-overview.html"},{default:(0,t.k6)((()=>[(0,t.eW)("数据结构 - Overview")])),_:1})])]),c,(0,t.Lk)("ul",null,[(0,t.Lk)("li",null,[(0,t.bF)(a,{to:"/md/algorithm/alg-basic-array.html"},{default:(0,t.k6)((()=>[(0,t.eW)("线性表 - 数组和矩阵")])),_:1}),h]),(0,t.Lk)("li",null,[(0,t.bF)(a,{to:"/md/algorithm/alg-basic-linklist.html"},{default:(0,t.k6)((()=>[(0,t.eW)("线性表 - 链表")])),_:1}),p]),(0,t.Lk)("li",null,[(0,t.bF)(a,{to:"/md/algorithm/alg-basic-hashtable.html"},{default:(0,t.k6)((()=>[(0,t.eW)("线性表(散列) - 哈希表")])),_:1}),d]),(0,t.Lk)("li",null,[(0,t.bF)(a,{to:"/md/algorithm/alg-basic-stack_queue.html"},{default:(0,t.k6)((()=>[(0,t.eW)("线性表 - 栈和队列")])),_:1}),m])]),s,(0,t.Lk)("ul",null,[(0,t.Lk)("li",null,[(0,t.bF)(a,{to:"/md/algorithm/alg-basic-tree.html"},{default:(0,t.k6)((()=>[(0,t.eW)("树 - 基础和Overview")])),_:1}),k]),(0,t.Lk)("li",null,[(0,t.bF)(a,{to:"/md/algorithm/alg-basic-tree-search.html"},{default:(0,t.k6)((()=>[(0,t.eW)("树 - 二叉搜索树(BST)")])),_:1}),E]),(0,t.Lk)("li",null,[(0,t.bF)(a,{to:"/md/algorithm/alg-basic-tree-balance.html"},{default:(0,t.k6)((()=>[(0,t.eW)("树 - 平衡二叉树(AVL)")])),_:1}),g]),(0,t.Lk)("li",null,[(0,t.bF)(a,{to:"/md/algorithm/alg-basic-tree-redblack.html"},{default:(0,t.k6)((()=>[(0,t.eW)("树 - 红黑树(R-B Tree)")])),_:1}),B]),(0,t.Lk)("li",null,[(0,t.bF)(a,{to:"/md/algorithm/alg-basic-tree-hafman.html"},{default:(0,t.k6)((()=>[(0,t.eW)("树 - 哈夫曼树")])),_:1}),b]),(0,t.Lk)("li",null,[(0,t.bF)(a,{to:"/md/algorithm/alg-basic-tree-trie.html"},{default:(0,t.k6)((()=>[(0,t.eW)("树 - 前缀树(Trie)")])),_:1}),L])]),A,(0,t.Lk)("ul",null,[(0,t.Lk)("li",null,[(0,t.bF)(a,{to:"/md/algorithm/alg-basic-graph.html"},{default:(0,t.k6)((()=>[(0,t.eW)("图 - 基础和Overview")])),_:1}),f]),(0,t.Lk)("li",null,[(0,t.bF)(a,{to:"/md/algorithm/alg-basic-graph-bfs-dfs.html"},{default:(0,t.k6)((()=>[(0,t.eW)("图 - 遍历(BFS & DFS)")])),_:1}),F]),(0,t.Lk)("li",null,[(0,t.bF)(a,{to:"/md/algorithm/alg-basic-graph-min-tree.html"},{default:(0,t.k6)((()=>[(0,t.eW)("图 - 最小生成树(Prim & Kruskal)")])),_:1}),w]),(0,t.Lk)("li",null,[(0,t.bF)(a,{to:"/md/algorithm/alg-basic-graph-min-distance.html"},{default:(0,t.k6)((()=>[(0,t.eW)("图 - 最短路径(Dijkstra & Frolyd)")])),_:1}),v]),(0,t.Lk)("li",null,[(0,t.bF)(a,{to:"/md/algorithm/alg-basic-graph-topo-sort.html"},{default:(0,t.k6)((()=>[(0,t.eW)("图 - 拓扑排序(Topological sort)")])),_:1}),_]),(0,t.Lk)("li",null,[(0,t.bF)(a,{to:"/md/algorithm/alg-basic-graph-aoe.html"},{default:(0,t.k6)((()=>[(0,t.eW)("图 - AOE & 关键路径")])),_:1}),D])]),y])}]]),x=JSON.parse('{"path":"/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.html","title":"# ♥数据结构基础知识体系详解♥","lang":"zh-CN","frontmatter":{"description":"# ♥数据结构基础知识体系详解♥ 提示 对于数据结构这种基础内容，在构建其知识体系时要避免自己再造轮子，需要高一点层次整体上去理解它(格局要大一点，不要盯着代码)，要了解算法思想，性能及适用场景，用一些工具和别人梳理的结果帮助自己构建知识体系等。@pdai # 知识体系 知识体系系统性梳理 学习思路 避免孤立的学习知识点，要关联学习。比如实际应用当中，...","head":[["meta",{"property":"og:url","content":"https://www.codenook.cn/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.html"}],["meta",{"property":"og:site_name","content":"知识体系"}],["meta",{"property":"og:title","content":"# ♥数据结构基础知识体系详解♥"}],["meta",{"property":"og:description","content":"# ♥数据结构基础知识体系详解♥ 提示 对于数据结构这种基础内容，在构建其知识体系时要避免自己再造轮子，需要高一点层次整体上去理解它(格局要大一点，不要盯着代码)，要了解算法思想，性能及适用场景，用一些工具和别人梳理的结果帮助自己构建知识体系等。@pdai # 知识体系 知识体系系统性梳理 学习思路 避免孤立的学习知识点，要关联学习。比如实际应用当中，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://pdai.tech/images/alg/alg-overview-x.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-04T14:55:43.000Z"}],["meta",{"property":"article:author","content":"XIONG XUECHUN"}],["meta",{"property":"article:modified_time","content":"2024-09-04T14:55:43.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"# ♥数据结构基础知识体系详解♥\\",\\"image\\":[\\"https://pdai.tech/images/alg/alg-overview-x.png\\"],\\"dateModified\\":\\"2024-09-04T14:55:43.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"XIONG XUECHUN\\",\\"url\\":\\"https://www.codenook.cn/\\",\\"email\\":\\"15293191747@163.com\\"}]}"]]},"headers":[{"level":2,"title":"# 入门推荐","slug":"入门推荐","link":"#入门推荐","children":[]},{"level":2,"title":"# 进阶推荐","slug":"进阶推荐","link":"#进阶推荐","children":[]},{"level":2,"title":"# 参考文章","slug":"参考文章","link":"#参考文章","children":[]}],"git":{"createdTime":1725461743000,"updatedTime":1725461743000,"contributors":[{"name":"xiongxc","email":"xiongxc@rd.netease.com","commits":1}]},"readingTime":{"minutes":9.36,"words":2808},"filePathRelative":"算法/数据结构知识体系/数据结构基础知识体系详解.md","localizedDate":"2024年9月4日","excerpt":"\\n<p>提示</p>\\n<p>对于数据结构这种基础内容，在构建其知识体系时要避免自己再造轮子，需要高一点层次整体上去理解它(格局要大一点，不要盯着代码)，要了解算法思想，性能及适用场景，用一些工具和别人梳理的结果帮助自己构建知识体系等。@pdai</p>\\n<ul>\\n<li><a href=\\"/md/algorithm/alg-basic-overview.html#%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB\\" target=\\"_blank\\">知识体系</a></li>\\n<li><a href=\\"/md/algorithm/alg-basic-overview.html#%E5%85%A5%E9%97%A8%E6%8E%A8%E8%8D%90\\" target=\\"_blank\\">入门推荐</a></li>\\n<li><a href=\\"/md/algorithm/alg-basic-overview.html#%E8%BF%9B%E9%98%B6%E6%8E%A8%E8%8D%90\\" target=\\"_blank\\">进阶推荐</a></li>\\n<li><a href=\\"/md/algorithm/alg-basic-overview.html#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0\\" target=\\"_blank\\">参考文章</a>\\n<a href=\\"#%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB\\">#</a> 知识体系</li>\\n</ul>","autoDesc":true}')}}]);